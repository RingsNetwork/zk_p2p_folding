/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.rings_node = (function() {
    
        /**
         * Namespace rings_node.
         * @exports rings_node
         * @namespace
         */
        var rings_node = {};
    
        rings_node.PeerInfo = (function() {
    
            /**
             * Properties of a PeerInfo.
             * @memberof rings_node
             * @interface IPeerInfo
             * @property {string|null} [did] PeerInfo did
             * @property {string|null} [state] PeerInfo state
             */
    
            /**
             * Constructs a new PeerInfo.
             * @memberof rings_node
             * @classdesc Represents a PeerInfo.
             * @implements IPeerInfo
             * @constructor
             * @param {rings_node.IPeerInfo=} [properties] Properties to set
             */
            function PeerInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerInfo did.
             * @member {string} did
             * @memberof rings_node.PeerInfo
             * @instance
             */
            PeerInfo.prototype.did = "";
    
            /**
             * PeerInfo state.
             * @member {string} state
             * @memberof rings_node.PeerInfo
             * @instance
             */
            PeerInfo.prototype.state = "";
    
            /**
             * Creates a new PeerInfo instance using the specified properties.
             * @function create
             * @memberof rings_node.PeerInfo
             * @static
             * @param {rings_node.IPeerInfo=} [properties] Properties to set
             * @returns {rings_node.PeerInfo} PeerInfo instance
             */
            PeerInfo.create = function create(properties) {
                return new PeerInfo(properties);
            };
    
            /**
             * Encodes the specified PeerInfo message. Does not implicitly {@link rings_node.PeerInfo.verify|verify} messages.
             * @function encode
             * @memberof rings_node.PeerInfo
             * @static
             * @param {rings_node.IPeerInfo} message PeerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.state);
                return writer;
            };
    
            /**
             * Encodes the specified PeerInfo message, length delimited. Does not implicitly {@link rings_node.PeerInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.PeerInfo
             * @static
             * @param {rings_node.IPeerInfo} message PeerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerInfo message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.PeerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.PeerInfo} PeerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.PeerInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    case 2: {
                            message.state = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.PeerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.PeerInfo} PeerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerInfo message.
             * @function verify
             * @memberof rings_node.PeerInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    if (!$util.isString(message.state))
                        return "state: string expected";
                return null;
            };
    
            /**
             * Creates a PeerInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.PeerInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.PeerInfo} PeerInfo
             */
            PeerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.PeerInfo)
                    return object;
                var message = new $root.rings_node.PeerInfo();
                if (object.did != null)
                    message.did = String(object.did);
                if (object.state != null)
                    message.state = String(object.state);
                return message;
            };
    
            /**
             * Creates a plain object from a PeerInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.PeerInfo
             * @static
             * @param {rings_node.PeerInfo} message PeerInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.did = "";
                    object.state = "";
                }
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = message.state;
                return object;
            };
    
            /**
             * Converts this PeerInfo to JSON.
             * @function toJSON
             * @memberof rings_node.PeerInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for PeerInfo
             * @function getTypeUrl
             * @memberof rings_node.PeerInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PeerInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.PeerInfo";
            };
    
            return PeerInfo;
        })();
    
        rings_node.ConnectPeerViaHttpRequest = (function() {
    
            /**
             * Properties of a ConnectPeerViaHttpRequest.
             * @memberof rings_node
             * @interface IConnectPeerViaHttpRequest
             * @property {string|null} [url] ConnectPeerViaHttpRequest url
             */
    
            /**
             * Constructs a new ConnectPeerViaHttpRequest.
             * @memberof rings_node
             * @classdesc Represents a ConnectPeerViaHttpRequest.
             * @implements IConnectPeerViaHttpRequest
             * @constructor
             * @param {rings_node.IConnectPeerViaHttpRequest=} [properties] Properties to set
             */
            function ConnectPeerViaHttpRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnectPeerViaHttpRequest url.
             * @member {string} url
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @instance
             */
            ConnectPeerViaHttpRequest.prototype.url = "";
    
            /**
             * Creates a new ConnectPeerViaHttpRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {rings_node.IConnectPeerViaHttpRequest=} [properties] Properties to set
             * @returns {rings_node.ConnectPeerViaHttpRequest} ConnectPeerViaHttpRequest instance
             */
            ConnectPeerViaHttpRequest.create = function create(properties) {
                return new ConnectPeerViaHttpRequest(properties);
            };
    
            /**
             * Encodes the specified ConnectPeerViaHttpRequest message. Does not implicitly {@link rings_node.ConnectPeerViaHttpRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {rings_node.IConnectPeerViaHttpRequest} message ConnectPeerViaHttpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectPeerViaHttpRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                return writer;
            };
    
            /**
             * Encodes the specified ConnectPeerViaHttpRequest message, length delimited. Does not implicitly {@link rings_node.ConnectPeerViaHttpRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {rings_node.IConnectPeerViaHttpRequest} message ConnectPeerViaHttpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectPeerViaHttpRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectPeerViaHttpRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ConnectPeerViaHttpRequest} ConnectPeerViaHttpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectPeerViaHttpRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ConnectPeerViaHttpRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectPeerViaHttpRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ConnectPeerViaHttpRequest} ConnectPeerViaHttpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectPeerViaHttpRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectPeerViaHttpRequest message.
             * @function verify
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectPeerViaHttpRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };
    
            /**
             * Creates a ConnectPeerViaHttpRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ConnectPeerViaHttpRequest} ConnectPeerViaHttpRequest
             */
            ConnectPeerViaHttpRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ConnectPeerViaHttpRequest)
                    return object;
                var message = new $root.rings_node.ConnectPeerViaHttpRequest();
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };
    
            /**
             * Creates a plain object from a ConnectPeerViaHttpRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {rings_node.ConnectPeerViaHttpRequest} message ConnectPeerViaHttpRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectPeerViaHttpRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.url = "";
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };
    
            /**
             * Converts this ConnectPeerViaHttpRequest to JSON.
             * @function toJSON
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectPeerViaHttpRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ConnectPeerViaHttpRequest
             * @function getTypeUrl
             * @memberof rings_node.ConnectPeerViaHttpRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConnectPeerViaHttpRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ConnectPeerViaHttpRequest";
            };
    
            return ConnectPeerViaHttpRequest;
        })();
    
        rings_node.ConnectPeerViaHttpResponse = (function() {
    
            /**
             * Properties of a ConnectPeerViaHttpResponse.
             * @memberof rings_node
             * @interface IConnectPeerViaHttpResponse
             * @property {rings_node.IPeerInfo|null} [peer] ConnectPeerViaHttpResponse peer
             */
    
            /**
             * Constructs a new ConnectPeerViaHttpResponse.
             * @memberof rings_node
             * @classdesc Represents a ConnectPeerViaHttpResponse.
             * @implements IConnectPeerViaHttpResponse
             * @constructor
             * @param {rings_node.IConnectPeerViaHttpResponse=} [properties] Properties to set
             */
            function ConnectPeerViaHttpResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnectPeerViaHttpResponse peer.
             * @member {rings_node.IPeerInfo|null|undefined} peer
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @instance
             */
            ConnectPeerViaHttpResponse.prototype.peer = null;
    
            /**
             * Creates a new ConnectPeerViaHttpResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {rings_node.IConnectPeerViaHttpResponse=} [properties] Properties to set
             * @returns {rings_node.ConnectPeerViaHttpResponse} ConnectPeerViaHttpResponse instance
             */
            ConnectPeerViaHttpResponse.create = function create(properties) {
                return new ConnectPeerViaHttpResponse(properties);
            };
    
            /**
             * Encodes the specified ConnectPeerViaHttpResponse message. Does not implicitly {@link rings_node.ConnectPeerViaHttpResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {rings_node.IConnectPeerViaHttpResponse} message ConnectPeerViaHttpResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectPeerViaHttpResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    $root.rings_node.PeerInfo.encode(message.peer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConnectPeerViaHttpResponse message, length delimited. Does not implicitly {@link rings_node.ConnectPeerViaHttpResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {rings_node.IConnectPeerViaHttpResponse} message ConnectPeerViaHttpResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectPeerViaHttpResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectPeerViaHttpResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ConnectPeerViaHttpResponse} ConnectPeerViaHttpResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectPeerViaHttpResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ConnectPeerViaHttpResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.peer = $root.rings_node.PeerInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectPeerViaHttpResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ConnectPeerViaHttpResponse} ConnectPeerViaHttpResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectPeerViaHttpResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectPeerViaHttpResponse message.
             * @function verify
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectPeerViaHttpResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peer != null && message.hasOwnProperty("peer")) {
                    var error = $root.rings_node.PeerInfo.verify(message.peer);
                    if (error)
                        return "peer." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConnectPeerViaHttpResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ConnectPeerViaHttpResponse} ConnectPeerViaHttpResponse
             */
            ConnectPeerViaHttpResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ConnectPeerViaHttpResponse)
                    return object;
                var message = new $root.rings_node.ConnectPeerViaHttpResponse();
                if (object.peer != null) {
                    if (typeof object.peer !== "object")
                        throw TypeError(".rings_node.ConnectPeerViaHttpResponse.peer: object expected");
                    message.peer = $root.rings_node.PeerInfo.fromObject(object.peer);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConnectPeerViaHttpResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {rings_node.ConnectPeerViaHttpResponse} message ConnectPeerViaHttpResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectPeerViaHttpResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.peer = null;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = $root.rings_node.PeerInfo.toObject(message.peer, options);
                return object;
            };
    
            /**
             * Converts this ConnectPeerViaHttpResponse to JSON.
             * @function toJSON
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectPeerViaHttpResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ConnectPeerViaHttpResponse
             * @function getTypeUrl
             * @memberof rings_node.ConnectPeerViaHttpResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConnectPeerViaHttpResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ConnectPeerViaHttpResponse";
            };
    
            return ConnectPeerViaHttpResponse;
        })();
    
        rings_node.ConnectWithDidRequest = (function() {
    
            /**
             * Properties of a ConnectWithDidRequest.
             * @memberof rings_node
             * @interface IConnectWithDidRequest
             * @property {string|null} [did] ConnectWithDidRequest did
             */
    
            /**
             * Constructs a new ConnectWithDidRequest.
             * @memberof rings_node
             * @classdesc Represents a ConnectWithDidRequest.
             * @implements IConnectWithDidRequest
             * @constructor
             * @param {rings_node.IConnectWithDidRequest=} [properties] Properties to set
             */
            function ConnectWithDidRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnectWithDidRequest did.
             * @member {string} did
             * @memberof rings_node.ConnectWithDidRequest
             * @instance
             */
            ConnectWithDidRequest.prototype.did = "";
    
            /**
             * Creates a new ConnectWithDidRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {rings_node.IConnectWithDidRequest=} [properties] Properties to set
             * @returns {rings_node.ConnectWithDidRequest} ConnectWithDidRequest instance
             */
            ConnectWithDidRequest.create = function create(properties) {
                return new ConnectWithDidRequest(properties);
            };
    
            /**
             * Encodes the specified ConnectWithDidRequest message. Does not implicitly {@link rings_node.ConnectWithDidRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {rings_node.IConnectWithDidRequest} message ConnectWithDidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithDidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                return writer;
            };
    
            /**
             * Encodes the specified ConnectWithDidRequest message, length delimited. Does not implicitly {@link rings_node.ConnectWithDidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {rings_node.IConnectWithDidRequest} message ConnectWithDidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithDidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectWithDidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ConnectWithDidRequest} ConnectWithDidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithDidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ConnectWithDidRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectWithDidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ConnectWithDidRequest} ConnectWithDidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithDidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectWithDidRequest message.
             * @function verify
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectWithDidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                return null;
            };
    
            /**
             * Creates a ConnectWithDidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ConnectWithDidRequest} ConnectWithDidRequest
             */
            ConnectWithDidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ConnectWithDidRequest)
                    return object;
                var message = new $root.rings_node.ConnectWithDidRequest();
                if (object.did != null)
                    message.did = String(object.did);
                return message;
            };
    
            /**
             * Creates a plain object from a ConnectWithDidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {rings_node.ConnectWithDidRequest} message ConnectWithDidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectWithDidRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.did = "";
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                return object;
            };
    
            /**
             * Converts this ConnectWithDidRequest to JSON.
             * @function toJSON
             * @memberof rings_node.ConnectWithDidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectWithDidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ConnectWithDidRequest
             * @function getTypeUrl
             * @memberof rings_node.ConnectWithDidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConnectWithDidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ConnectWithDidRequest";
            };
    
            return ConnectWithDidRequest;
        })();
    
        rings_node.ConnectWithDidResponse = (function() {
    
            /**
             * Properties of a ConnectWithDidResponse.
             * @memberof rings_node
             * @interface IConnectWithDidResponse
             */
    
            /**
             * Constructs a new ConnectWithDidResponse.
             * @memberof rings_node
             * @classdesc Represents a ConnectWithDidResponse.
             * @implements IConnectWithDidResponse
             * @constructor
             * @param {rings_node.IConnectWithDidResponse=} [properties] Properties to set
             */
            function ConnectWithDidResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ConnectWithDidResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {rings_node.IConnectWithDidResponse=} [properties] Properties to set
             * @returns {rings_node.ConnectWithDidResponse} ConnectWithDidResponse instance
             */
            ConnectWithDidResponse.create = function create(properties) {
                return new ConnectWithDidResponse(properties);
            };
    
            /**
             * Encodes the specified ConnectWithDidResponse message. Does not implicitly {@link rings_node.ConnectWithDidResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {rings_node.IConnectWithDidResponse} message ConnectWithDidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithDidResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ConnectWithDidResponse message, length delimited. Does not implicitly {@link rings_node.ConnectWithDidResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {rings_node.IConnectWithDidResponse} message ConnectWithDidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithDidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectWithDidResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ConnectWithDidResponse} ConnectWithDidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithDidResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ConnectWithDidResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectWithDidResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ConnectWithDidResponse} ConnectWithDidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithDidResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectWithDidResponse message.
             * @function verify
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectWithDidResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ConnectWithDidResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ConnectWithDidResponse} ConnectWithDidResponse
             */
            ConnectWithDidResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ConnectWithDidResponse)
                    return object;
                return new $root.rings_node.ConnectWithDidResponse();
            };
    
            /**
             * Creates a plain object from a ConnectWithDidResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {rings_node.ConnectWithDidResponse} message ConnectWithDidResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectWithDidResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ConnectWithDidResponse to JSON.
             * @function toJSON
             * @memberof rings_node.ConnectWithDidResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectWithDidResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ConnectWithDidResponse
             * @function getTypeUrl
             * @memberof rings_node.ConnectWithDidResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConnectWithDidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ConnectWithDidResponse";
            };
    
            return ConnectWithDidResponse;
        })();
    
        rings_node.SeedPeer = (function() {
    
            /**
             * Properties of a SeedPeer.
             * @memberof rings_node
             * @interface ISeedPeer
             * @property {string|null} [did] SeedPeer did
             * @property {string|null} [url] SeedPeer url
             */
    
            /**
             * Constructs a new SeedPeer.
             * @memberof rings_node
             * @classdesc Represents a SeedPeer.
             * @implements ISeedPeer
             * @constructor
             * @param {rings_node.ISeedPeer=} [properties] Properties to set
             */
            function SeedPeer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeedPeer did.
             * @member {string} did
             * @memberof rings_node.SeedPeer
             * @instance
             */
            SeedPeer.prototype.did = "";
    
            /**
             * SeedPeer url.
             * @member {string} url
             * @memberof rings_node.SeedPeer
             * @instance
             */
            SeedPeer.prototype.url = "";
    
            /**
             * Creates a new SeedPeer instance using the specified properties.
             * @function create
             * @memberof rings_node.SeedPeer
             * @static
             * @param {rings_node.ISeedPeer=} [properties] Properties to set
             * @returns {rings_node.SeedPeer} SeedPeer instance
             */
            SeedPeer.create = function create(properties) {
                return new SeedPeer(properties);
            };
    
            /**
             * Encodes the specified SeedPeer message. Does not implicitly {@link rings_node.SeedPeer.verify|verify} messages.
             * @function encode
             * @memberof rings_node.SeedPeer
             * @static
             * @param {rings_node.ISeedPeer} message SeedPeer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeedPeer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                return writer;
            };
    
            /**
             * Encodes the specified SeedPeer message, length delimited. Does not implicitly {@link rings_node.SeedPeer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.SeedPeer
             * @static
             * @param {rings_node.ISeedPeer} message SeedPeer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeedPeer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeedPeer message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.SeedPeer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.SeedPeer} SeedPeer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeedPeer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.SeedPeer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeedPeer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.SeedPeer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.SeedPeer} SeedPeer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeedPeer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeedPeer message.
             * @function verify
             * @memberof rings_node.SeedPeer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeedPeer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };
    
            /**
             * Creates a SeedPeer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.SeedPeer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.SeedPeer} SeedPeer
             */
            SeedPeer.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.SeedPeer)
                    return object;
                var message = new $root.rings_node.SeedPeer();
                if (object.did != null)
                    message.did = String(object.did);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };
    
            /**
             * Creates a plain object from a SeedPeer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.SeedPeer
             * @static
             * @param {rings_node.SeedPeer} message SeedPeer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeedPeer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.did = "";
                    object.url = "";
                }
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };
    
            /**
             * Converts this SeedPeer to JSON.
             * @function toJSON
             * @memberof rings_node.SeedPeer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeedPeer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SeedPeer
             * @function getTypeUrl
             * @memberof rings_node.SeedPeer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SeedPeer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.SeedPeer";
            };
    
            return SeedPeer;
        })();
    
        rings_node.ConnectWithSeedRequest = (function() {
    
            /**
             * Properties of a ConnectWithSeedRequest.
             * @memberof rings_node
             * @interface IConnectWithSeedRequest
             * @property {Array.<rings_node.ISeedPeer>|null} [peers] ConnectWithSeedRequest peers
             */
    
            /**
             * Constructs a new ConnectWithSeedRequest.
             * @memberof rings_node
             * @classdesc Represents a ConnectWithSeedRequest.
             * @implements IConnectWithSeedRequest
             * @constructor
             * @param {rings_node.IConnectWithSeedRequest=} [properties] Properties to set
             */
            function ConnectWithSeedRequest(properties) {
                this.peers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnectWithSeedRequest peers.
             * @member {Array.<rings_node.ISeedPeer>} peers
             * @memberof rings_node.ConnectWithSeedRequest
             * @instance
             */
            ConnectWithSeedRequest.prototype.peers = $util.emptyArray;
    
            /**
             * Creates a new ConnectWithSeedRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {rings_node.IConnectWithSeedRequest=} [properties] Properties to set
             * @returns {rings_node.ConnectWithSeedRequest} ConnectWithSeedRequest instance
             */
            ConnectWithSeedRequest.create = function create(properties) {
                return new ConnectWithSeedRequest(properties);
            };
    
            /**
             * Encodes the specified ConnectWithSeedRequest message. Does not implicitly {@link rings_node.ConnectWithSeedRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {rings_node.IConnectWithSeedRequest} message ConnectWithSeedRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithSeedRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers != null && message.peers.length)
                    for (var i = 0; i < message.peers.length; ++i)
                        $root.rings_node.SeedPeer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConnectWithSeedRequest message, length delimited. Does not implicitly {@link rings_node.ConnectWithSeedRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {rings_node.IConnectWithSeedRequest} message ConnectWithSeedRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithSeedRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectWithSeedRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ConnectWithSeedRequest} ConnectWithSeedRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithSeedRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ConnectWithSeedRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.peers && message.peers.length))
                                message.peers = [];
                            message.peers.push($root.rings_node.SeedPeer.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectWithSeedRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ConnectWithSeedRequest} ConnectWithSeedRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithSeedRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectWithSeedRequest message.
             * @function verify
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectWithSeedRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers != null && message.hasOwnProperty("peers")) {
                    if (!Array.isArray(message.peers))
                        return "peers: array expected";
                    for (var i = 0; i < message.peers.length; ++i) {
                        var error = $root.rings_node.SeedPeer.verify(message.peers[i]);
                        if (error)
                            return "peers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ConnectWithSeedRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ConnectWithSeedRequest} ConnectWithSeedRequest
             */
            ConnectWithSeedRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ConnectWithSeedRequest)
                    return object;
                var message = new $root.rings_node.ConnectWithSeedRequest();
                if (object.peers) {
                    if (!Array.isArray(object.peers))
                        throw TypeError(".rings_node.ConnectWithSeedRequest.peers: array expected");
                    message.peers = [];
                    for (var i = 0; i < object.peers.length; ++i) {
                        if (typeof object.peers[i] !== "object")
                            throw TypeError(".rings_node.ConnectWithSeedRequest.peers: object expected");
                        message.peers[i] = $root.rings_node.SeedPeer.fromObject(object.peers[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConnectWithSeedRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {rings_node.ConnectWithSeedRequest} message ConnectWithSeedRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectWithSeedRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.peers = [];
                if (message.peers && message.peers.length) {
                    object.peers = [];
                    for (var j = 0; j < message.peers.length; ++j)
                        object.peers[j] = $root.rings_node.SeedPeer.toObject(message.peers[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ConnectWithSeedRequest to JSON.
             * @function toJSON
             * @memberof rings_node.ConnectWithSeedRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectWithSeedRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ConnectWithSeedRequest
             * @function getTypeUrl
             * @memberof rings_node.ConnectWithSeedRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConnectWithSeedRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ConnectWithSeedRequest";
            };
    
            return ConnectWithSeedRequest;
        })();
    
        rings_node.ConnectWithSeedResponse = (function() {
    
            /**
             * Properties of a ConnectWithSeedResponse.
             * @memberof rings_node
             * @interface IConnectWithSeedResponse
             */
    
            /**
             * Constructs a new ConnectWithSeedResponse.
             * @memberof rings_node
             * @classdesc Represents a ConnectWithSeedResponse.
             * @implements IConnectWithSeedResponse
             * @constructor
             * @param {rings_node.IConnectWithSeedResponse=} [properties] Properties to set
             */
            function ConnectWithSeedResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ConnectWithSeedResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {rings_node.IConnectWithSeedResponse=} [properties] Properties to set
             * @returns {rings_node.ConnectWithSeedResponse} ConnectWithSeedResponse instance
             */
            ConnectWithSeedResponse.create = function create(properties) {
                return new ConnectWithSeedResponse(properties);
            };
    
            /**
             * Encodes the specified ConnectWithSeedResponse message. Does not implicitly {@link rings_node.ConnectWithSeedResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {rings_node.IConnectWithSeedResponse} message ConnectWithSeedResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithSeedResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ConnectWithSeedResponse message, length delimited. Does not implicitly {@link rings_node.ConnectWithSeedResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {rings_node.IConnectWithSeedResponse} message ConnectWithSeedResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectWithSeedResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectWithSeedResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ConnectWithSeedResponse} ConnectWithSeedResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithSeedResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ConnectWithSeedResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectWithSeedResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ConnectWithSeedResponse} ConnectWithSeedResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectWithSeedResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectWithSeedResponse message.
             * @function verify
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectWithSeedResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ConnectWithSeedResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ConnectWithSeedResponse} ConnectWithSeedResponse
             */
            ConnectWithSeedResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ConnectWithSeedResponse)
                    return object;
                return new $root.rings_node.ConnectWithSeedResponse();
            };
    
            /**
             * Creates a plain object from a ConnectWithSeedResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {rings_node.ConnectWithSeedResponse} message ConnectWithSeedResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectWithSeedResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ConnectWithSeedResponse to JSON.
             * @function toJSON
             * @memberof rings_node.ConnectWithSeedResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectWithSeedResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ConnectWithSeedResponse
             * @function getTypeUrl
             * @memberof rings_node.ConnectWithSeedResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConnectWithSeedResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ConnectWithSeedResponse";
            };
    
            return ConnectWithSeedResponse;
        })();
    
        rings_node.ListPeersRequest = (function() {
    
            /**
             * Properties of a ListPeersRequest.
             * @memberof rings_node
             * @interface IListPeersRequest
             */
    
            /**
             * Constructs a new ListPeersRequest.
             * @memberof rings_node
             * @classdesc Represents a ListPeersRequest.
             * @implements IListPeersRequest
             * @constructor
             * @param {rings_node.IListPeersRequest=} [properties] Properties to set
             */
            function ListPeersRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ListPeersRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {rings_node.IListPeersRequest=} [properties] Properties to set
             * @returns {rings_node.ListPeersRequest} ListPeersRequest instance
             */
            ListPeersRequest.create = function create(properties) {
                return new ListPeersRequest(properties);
            };
    
            /**
             * Encodes the specified ListPeersRequest message. Does not implicitly {@link rings_node.ListPeersRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {rings_node.IListPeersRequest} message ListPeersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListPeersRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ListPeersRequest message, length delimited. Does not implicitly {@link rings_node.ListPeersRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {rings_node.IListPeersRequest} message ListPeersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ListPeersRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ListPeersRequest} ListPeersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListPeersRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ListPeersRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ListPeersRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ListPeersRequest} ListPeersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListPeersRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ListPeersRequest message.
             * @function verify
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListPeersRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ListPeersRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ListPeersRequest} ListPeersRequest
             */
            ListPeersRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ListPeersRequest)
                    return object;
                return new $root.rings_node.ListPeersRequest();
            };
    
            /**
             * Creates a plain object from a ListPeersRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {rings_node.ListPeersRequest} message ListPeersRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListPeersRequest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ListPeersRequest to JSON.
             * @function toJSON
             * @memberof rings_node.ListPeersRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListPeersRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ListPeersRequest
             * @function getTypeUrl
             * @memberof rings_node.ListPeersRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ListPeersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ListPeersRequest";
            };
    
            return ListPeersRequest;
        })();
    
        rings_node.ListPeersResponse = (function() {
    
            /**
             * Properties of a ListPeersResponse.
             * @memberof rings_node
             * @interface IListPeersResponse
             * @property {Array.<rings_node.IPeerInfo>|null} [peers] ListPeersResponse peers
             */
    
            /**
             * Constructs a new ListPeersResponse.
             * @memberof rings_node
             * @classdesc Represents a ListPeersResponse.
             * @implements IListPeersResponse
             * @constructor
             * @param {rings_node.IListPeersResponse=} [properties] Properties to set
             */
            function ListPeersResponse(properties) {
                this.peers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ListPeersResponse peers.
             * @member {Array.<rings_node.IPeerInfo>} peers
             * @memberof rings_node.ListPeersResponse
             * @instance
             */
            ListPeersResponse.prototype.peers = $util.emptyArray;
    
            /**
             * Creates a new ListPeersResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {rings_node.IListPeersResponse=} [properties] Properties to set
             * @returns {rings_node.ListPeersResponse} ListPeersResponse instance
             */
            ListPeersResponse.create = function create(properties) {
                return new ListPeersResponse(properties);
            };
    
            /**
             * Encodes the specified ListPeersResponse message. Does not implicitly {@link rings_node.ListPeersResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {rings_node.IListPeersResponse} message ListPeersResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListPeersResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers != null && message.peers.length)
                    for (var i = 0; i < message.peers.length; ++i)
                        $root.rings_node.PeerInfo.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ListPeersResponse message, length delimited. Does not implicitly {@link rings_node.ListPeersResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {rings_node.IListPeersResponse} message ListPeersResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListPeersResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ListPeersResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.ListPeersResponse} ListPeersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListPeersResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.ListPeersResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.peers && message.peers.length))
                                message.peers = [];
                            message.peers.push($root.rings_node.PeerInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ListPeersResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.ListPeersResponse} ListPeersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListPeersResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ListPeersResponse message.
             * @function verify
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListPeersResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers != null && message.hasOwnProperty("peers")) {
                    if (!Array.isArray(message.peers))
                        return "peers: array expected";
                    for (var i = 0; i < message.peers.length; ++i) {
                        var error = $root.rings_node.PeerInfo.verify(message.peers[i]);
                        if (error)
                            return "peers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ListPeersResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.ListPeersResponse} ListPeersResponse
             */
            ListPeersResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.ListPeersResponse)
                    return object;
                var message = new $root.rings_node.ListPeersResponse();
                if (object.peers) {
                    if (!Array.isArray(object.peers))
                        throw TypeError(".rings_node.ListPeersResponse.peers: array expected");
                    message.peers = [];
                    for (var i = 0; i < object.peers.length; ++i) {
                        if (typeof object.peers[i] !== "object")
                            throw TypeError(".rings_node.ListPeersResponse.peers: object expected");
                        message.peers[i] = $root.rings_node.PeerInfo.fromObject(object.peers[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ListPeersResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {rings_node.ListPeersResponse} message ListPeersResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListPeersResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.peers = [];
                if (message.peers && message.peers.length) {
                    object.peers = [];
                    for (var j = 0; j < message.peers.length; ++j)
                        object.peers[j] = $root.rings_node.PeerInfo.toObject(message.peers[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ListPeersResponse to JSON.
             * @function toJSON
             * @memberof rings_node.ListPeersResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListPeersResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ListPeersResponse
             * @function getTypeUrl
             * @memberof rings_node.ListPeersResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ListPeersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.ListPeersResponse";
            };
    
            return ListPeersResponse;
        })();
    
        rings_node.CreateOfferRequest = (function() {
    
            /**
             * Properties of a CreateOfferRequest.
             * @memberof rings_node
             * @interface ICreateOfferRequest
             * @property {string|null} [did] CreateOfferRequest did
             */
    
            /**
             * Constructs a new CreateOfferRequest.
             * @memberof rings_node
             * @classdesc Represents a CreateOfferRequest.
             * @implements ICreateOfferRequest
             * @constructor
             * @param {rings_node.ICreateOfferRequest=} [properties] Properties to set
             */
            function CreateOfferRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CreateOfferRequest did.
             * @member {string} did
             * @memberof rings_node.CreateOfferRequest
             * @instance
             */
            CreateOfferRequest.prototype.did = "";
    
            /**
             * Creates a new CreateOfferRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {rings_node.ICreateOfferRequest=} [properties] Properties to set
             * @returns {rings_node.CreateOfferRequest} CreateOfferRequest instance
             */
            CreateOfferRequest.create = function create(properties) {
                return new CreateOfferRequest(properties);
            };
    
            /**
             * Encodes the specified CreateOfferRequest message. Does not implicitly {@link rings_node.CreateOfferRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {rings_node.ICreateOfferRequest} message CreateOfferRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateOfferRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                return writer;
            };
    
            /**
             * Encodes the specified CreateOfferRequest message, length delimited. Does not implicitly {@link rings_node.CreateOfferRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {rings_node.ICreateOfferRequest} message CreateOfferRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateOfferRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CreateOfferRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.CreateOfferRequest} CreateOfferRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateOfferRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.CreateOfferRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CreateOfferRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.CreateOfferRequest} CreateOfferRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateOfferRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CreateOfferRequest message.
             * @function verify
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateOfferRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                return null;
            };
    
            /**
             * Creates a CreateOfferRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.CreateOfferRequest} CreateOfferRequest
             */
            CreateOfferRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.CreateOfferRequest)
                    return object;
                var message = new $root.rings_node.CreateOfferRequest();
                if (object.did != null)
                    message.did = String(object.did);
                return message;
            };
    
            /**
             * Creates a plain object from a CreateOfferRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {rings_node.CreateOfferRequest} message CreateOfferRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateOfferRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.did = "";
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                return object;
            };
    
            /**
             * Converts this CreateOfferRequest to JSON.
             * @function toJSON
             * @memberof rings_node.CreateOfferRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateOfferRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CreateOfferRequest
             * @function getTypeUrl
             * @memberof rings_node.CreateOfferRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateOfferRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.CreateOfferRequest";
            };
    
            return CreateOfferRequest;
        })();
    
        rings_node.CreateOfferResponse = (function() {
    
            /**
             * Properties of a CreateOfferResponse.
             * @memberof rings_node
             * @interface ICreateOfferResponse
             * @property {string|null} [offer] CreateOfferResponse offer
             */
    
            /**
             * Constructs a new CreateOfferResponse.
             * @memberof rings_node
             * @classdesc Represents a CreateOfferResponse.
             * @implements ICreateOfferResponse
             * @constructor
             * @param {rings_node.ICreateOfferResponse=} [properties] Properties to set
             */
            function CreateOfferResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CreateOfferResponse offer.
             * @member {string} offer
             * @memberof rings_node.CreateOfferResponse
             * @instance
             */
            CreateOfferResponse.prototype.offer = "";
    
            /**
             * Creates a new CreateOfferResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {rings_node.ICreateOfferResponse=} [properties] Properties to set
             * @returns {rings_node.CreateOfferResponse} CreateOfferResponse instance
             */
            CreateOfferResponse.create = function create(properties) {
                return new CreateOfferResponse(properties);
            };
    
            /**
             * Encodes the specified CreateOfferResponse message. Does not implicitly {@link rings_node.CreateOfferResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {rings_node.ICreateOfferResponse} message CreateOfferResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateOfferResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.offer);
                return writer;
            };
    
            /**
             * Encodes the specified CreateOfferResponse message, length delimited. Does not implicitly {@link rings_node.CreateOfferResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {rings_node.ICreateOfferResponse} message CreateOfferResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateOfferResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CreateOfferResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.CreateOfferResponse} CreateOfferResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateOfferResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.CreateOfferResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.offer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CreateOfferResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.CreateOfferResponse} CreateOfferResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateOfferResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CreateOfferResponse message.
             * @function verify
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateOfferResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.offer != null && message.hasOwnProperty("offer"))
                    if (!$util.isString(message.offer))
                        return "offer: string expected";
                return null;
            };
    
            /**
             * Creates a CreateOfferResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.CreateOfferResponse} CreateOfferResponse
             */
            CreateOfferResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.CreateOfferResponse)
                    return object;
                var message = new $root.rings_node.CreateOfferResponse();
                if (object.offer != null)
                    message.offer = String(object.offer);
                return message;
            };
    
            /**
             * Creates a plain object from a CreateOfferResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {rings_node.CreateOfferResponse} message CreateOfferResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateOfferResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.offer = "";
                if (message.offer != null && message.hasOwnProperty("offer"))
                    object.offer = message.offer;
                return object;
            };
    
            /**
             * Converts this CreateOfferResponse to JSON.
             * @function toJSON
             * @memberof rings_node.CreateOfferResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateOfferResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CreateOfferResponse
             * @function getTypeUrl
             * @memberof rings_node.CreateOfferResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateOfferResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.CreateOfferResponse";
            };
    
            return CreateOfferResponse;
        })();
    
        rings_node.AnswerOfferRequest = (function() {
    
            /**
             * Properties of an AnswerOfferRequest.
             * @memberof rings_node
             * @interface IAnswerOfferRequest
             * @property {string|null} [offer] AnswerOfferRequest offer
             */
    
            /**
             * Constructs a new AnswerOfferRequest.
             * @memberof rings_node
             * @classdesc Represents an AnswerOfferRequest.
             * @implements IAnswerOfferRequest
             * @constructor
             * @param {rings_node.IAnswerOfferRequest=} [properties] Properties to set
             */
            function AnswerOfferRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AnswerOfferRequest offer.
             * @member {string} offer
             * @memberof rings_node.AnswerOfferRequest
             * @instance
             */
            AnswerOfferRequest.prototype.offer = "";
    
            /**
             * Creates a new AnswerOfferRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {rings_node.IAnswerOfferRequest=} [properties] Properties to set
             * @returns {rings_node.AnswerOfferRequest} AnswerOfferRequest instance
             */
            AnswerOfferRequest.create = function create(properties) {
                return new AnswerOfferRequest(properties);
            };
    
            /**
             * Encodes the specified AnswerOfferRequest message. Does not implicitly {@link rings_node.AnswerOfferRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {rings_node.IAnswerOfferRequest} message AnswerOfferRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnswerOfferRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.offer);
                return writer;
            };
    
            /**
             * Encodes the specified AnswerOfferRequest message, length delimited. Does not implicitly {@link rings_node.AnswerOfferRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {rings_node.IAnswerOfferRequest} message AnswerOfferRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnswerOfferRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnswerOfferRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.AnswerOfferRequest} AnswerOfferRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnswerOfferRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.AnswerOfferRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.offer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AnswerOfferRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.AnswerOfferRequest} AnswerOfferRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnswerOfferRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnswerOfferRequest message.
             * @function verify
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnswerOfferRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.offer != null && message.hasOwnProperty("offer"))
                    if (!$util.isString(message.offer))
                        return "offer: string expected";
                return null;
            };
    
            /**
             * Creates an AnswerOfferRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.AnswerOfferRequest} AnswerOfferRequest
             */
            AnswerOfferRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.AnswerOfferRequest)
                    return object;
                var message = new $root.rings_node.AnswerOfferRequest();
                if (object.offer != null)
                    message.offer = String(object.offer);
                return message;
            };
    
            /**
             * Creates a plain object from an AnswerOfferRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {rings_node.AnswerOfferRequest} message AnswerOfferRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnswerOfferRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.offer = "";
                if (message.offer != null && message.hasOwnProperty("offer"))
                    object.offer = message.offer;
                return object;
            };
    
            /**
             * Converts this AnswerOfferRequest to JSON.
             * @function toJSON
             * @memberof rings_node.AnswerOfferRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnswerOfferRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for AnswerOfferRequest
             * @function getTypeUrl
             * @memberof rings_node.AnswerOfferRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AnswerOfferRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.AnswerOfferRequest";
            };
    
            return AnswerOfferRequest;
        })();
    
        rings_node.AnswerOfferResponse = (function() {
    
            /**
             * Properties of an AnswerOfferResponse.
             * @memberof rings_node
             * @interface IAnswerOfferResponse
             * @property {string|null} [answer] AnswerOfferResponse answer
             */
    
            /**
             * Constructs a new AnswerOfferResponse.
             * @memberof rings_node
             * @classdesc Represents an AnswerOfferResponse.
             * @implements IAnswerOfferResponse
             * @constructor
             * @param {rings_node.IAnswerOfferResponse=} [properties] Properties to set
             */
            function AnswerOfferResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AnswerOfferResponse answer.
             * @member {string} answer
             * @memberof rings_node.AnswerOfferResponse
             * @instance
             */
            AnswerOfferResponse.prototype.answer = "";
    
            /**
             * Creates a new AnswerOfferResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {rings_node.IAnswerOfferResponse=} [properties] Properties to set
             * @returns {rings_node.AnswerOfferResponse} AnswerOfferResponse instance
             */
            AnswerOfferResponse.create = function create(properties) {
                return new AnswerOfferResponse(properties);
            };
    
            /**
             * Encodes the specified AnswerOfferResponse message. Does not implicitly {@link rings_node.AnswerOfferResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {rings_node.IAnswerOfferResponse} message AnswerOfferResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnswerOfferResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.answer != null && Object.hasOwnProperty.call(message, "answer"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.answer);
                return writer;
            };
    
            /**
             * Encodes the specified AnswerOfferResponse message, length delimited. Does not implicitly {@link rings_node.AnswerOfferResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {rings_node.IAnswerOfferResponse} message AnswerOfferResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnswerOfferResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnswerOfferResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.AnswerOfferResponse} AnswerOfferResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnswerOfferResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.AnswerOfferResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.answer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AnswerOfferResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.AnswerOfferResponse} AnswerOfferResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnswerOfferResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnswerOfferResponse message.
             * @function verify
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnswerOfferResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.answer != null && message.hasOwnProperty("answer"))
                    if (!$util.isString(message.answer))
                        return "answer: string expected";
                return null;
            };
    
            /**
             * Creates an AnswerOfferResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.AnswerOfferResponse} AnswerOfferResponse
             */
            AnswerOfferResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.AnswerOfferResponse)
                    return object;
                var message = new $root.rings_node.AnswerOfferResponse();
                if (object.answer != null)
                    message.answer = String(object.answer);
                return message;
            };
    
            /**
             * Creates a plain object from an AnswerOfferResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {rings_node.AnswerOfferResponse} message AnswerOfferResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnswerOfferResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.answer = "";
                if (message.answer != null && message.hasOwnProperty("answer"))
                    object.answer = message.answer;
                return object;
            };
    
            /**
             * Converts this AnswerOfferResponse to JSON.
             * @function toJSON
             * @memberof rings_node.AnswerOfferResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnswerOfferResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for AnswerOfferResponse
             * @function getTypeUrl
             * @memberof rings_node.AnswerOfferResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AnswerOfferResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.AnswerOfferResponse";
            };
    
            return AnswerOfferResponse;
        })();
    
        rings_node.AcceptAnswerRequest = (function() {
    
            /**
             * Properties of an AcceptAnswerRequest.
             * @memberof rings_node
             * @interface IAcceptAnswerRequest
             * @property {string|null} [answer] AcceptAnswerRequest answer
             */
    
            /**
             * Constructs a new AcceptAnswerRequest.
             * @memberof rings_node
             * @classdesc Represents an AcceptAnswerRequest.
             * @implements IAcceptAnswerRequest
             * @constructor
             * @param {rings_node.IAcceptAnswerRequest=} [properties] Properties to set
             */
            function AcceptAnswerRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AcceptAnswerRequest answer.
             * @member {string} answer
             * @memberof rings_node.AcceptAnswerRequest
             * @instance
             */
            AcceptAnswerRequest.prototype.answer = "";
    
            /**
             * Creates a new AcceptAnswerRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {rings_node.IAcceptAnswerRequest=} [properties] Properties to set
             * @returns {rings_node.AcceptAnswerRequest} AcceptAnswerRequest instance
             */
            AcceptAnswerRequest.create = function create(properties) {
                return new AcceptAnswerRequest(properties);
            };
    
            /**
             * Encodes the specified AcceptAnswerRequest message. Does not implicitly {@link rings_node.AcceptAnswerRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {rings_node.IAcceptAnswerRequest} message AcceptAnswerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AcceptAnswerRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.answer != null && Object.hasOwnProperty.call(message, "answer"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.answer);
                return writer;
            };
    
            /**
             * Encodes the specified AcceptAnswerRequest message, length delimited. Does not implicitly {@link rings_node.AcceptAnswerRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {rings_node.IAcceptAnswerRequest} message AcceptAnswerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AcceptAnswerRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AcceptAnswerRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.AcceptAnswerRequest} AcceptAnswerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AcceptAnswerRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.AcceptAnswerRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.answer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AcceptAnswerRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.AcceptAnswerRequest} AcceptAnswerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AcceptAnswerRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AcceptAnswerRequest message.
             * @function verify
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AcceptAnswerRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.answer != null && message.hasOwnProperty("answer"))
                    if (!$util.isString(message.answer))
                        return "answer: string expected";
                return null;
            };
    
            /**
             * Creates an AcceptAnswerRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.AcceptAnswerRequest} AcceptAnswerRequest
             */
            AcceptAnswerRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.AcceptAnswerRequest)
                    return object;
                var message = new $root.rings_node.AcceptAnswerRequest();
                if (object.answer != null)
                    message.answer = String(object.answer);
                return message;
            };
    
            /**
             * Creates a plain object from an AcceptAnswerRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {rings_node.AcceptAnswerRequest} message AcceptAnswerRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AcceptAnswerRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.answer = "";
                if (message.answer != null && message.hasOwnProperty("answer"))
                    object.answer = message.answer;
                return object;
            };
    
            /**
             * Converts this AcceptAnswerRequest to JSON.
             * @function toJSON
             * @memberof rings_node.AcceptAnswerRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AcceptAnswerRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for AcceptAnswerRequest
             * @function getTypeUrl
             * @memberof rings_node.AcceptAnswerRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AcceptAnswerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.AcceptAnswerRequest";
            };
    
            return AcceptAnswerRequest;
        })();
    
        rings_node.AcceptAnswerResponse = (function() {
    
            /**
             * Properties of an AcceptAnswerResponse.
             * @memberof rings_node
             * @interface IAcceptAnswerResponse
             * @property {rings_node.IPeerInfo|null} [peer] AcceptAnswerResponse peer
             */
    
            /**
             * Constructs a new AcceptAnswerResponse.
             * @memberof rings_node
             * @classdesc Represents an AcceptAnswerResponse.
             * @implements IAcceptAnswerResponse
             * @constructor
             * @param {rings_node.IAcceptAnswerResponse=} [properties] Properties to set
             */
            function AcceptAnswerResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AcceptAnswerResponse peer.
             * @member {rings_node.IPeerInfo|null|undefined} peer
             * @memberof rings_node.AcceptAnswerResponse
             * @instance
             */
            AcceptAnswerResponse.prototype.peer = null;
    
            /**
             * Creates a new AcceptAnswerResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {rings_node.IAcceptAnswerResponse=} [properties] Properties to set
             * @returns {rings_node.AcceptAnswerResponse} AcceptAnswerResponse instance
             */
            AcceptAnswerResponse.create = function create(properties) {
                return new AcceptAnswerResponse(properties);
            };
    
            /**
             * Encodes the specified AcceptAnswerResponse message. Does not implicitly {@link rings_node.AcceptAnswerResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {rings_node.IAcceptAnswerResponse} message AcceptAnswerResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AcceptAnswerResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    $root.rings_node.PeerInfo.encode(message.peer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified AcceptAnswerResponse message, length delimited. Does not implicitly {@link rings_node.AcceptAnswerResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {rings_node.IAcceptAnswerResponse} message AcceptAnswerResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AcceptAnswerResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AcceptAnswerResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.AcceptAnswerResponse} AcceptAnswerResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AcceptAnswerResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.AcceptAnswerResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.peer = $root.rings_node.PeerInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AcceptAnswerResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.AcceptAnswerResponse} AcceptAnswerResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AcceptAnswerResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AcceptAnswerResponse message.
             * @function verify
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AcceptAnswerResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peer != null && message.hasOwnProperty("peer")) {
                    var error = $root.rings_node.PeerInfo.verify(message.peer);
                    if (error)
                        return "peer." + error;
                }
                return null;
            };
    
            /**
             * Creates an AcceptAnswerResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.AcceptAnswerResponse} AcceptAnswerResponse
             */
            AcceptAnswerResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.AcceptAnswerResponse)
                    return object;
                var message = new $root.rings_node.AcceptAnswerResponse();
                if (object.peer != null) {
                    if (typeof object.peer !== "object")
                        throw TypeError(".rings_node.AcceptAnswerResponse.peer: object expected");
                    message.peer = $root.rings_node.PeerInfo.fromObject(object.peer);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an AcceptAnswerResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {rings_node.AcceptAnswerResponse} message AcceptAnswerResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AcceptAnswerResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.peer = null;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = $root.rings_node.PeerInfo.toObject(message.peer, options);
                return object;
            };
    
            /**
             * Converts this AcceptAnswerResponse to JSON.
             * @function toJSON
             * @memberof rings_node.AcceptAnswerResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AcceptAnswerResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for AcceptAnswerResponse
             * @function getTypeUrl
             * @memberof rings_node.AcceptAnswerResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AcceptAnswerResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.AcceptAnswerResponse";
            };
    
            return AcceptAnswerResponse;
        })();
    
        rings_node.DisconnectRequest = (function() {
    
            /**
             * Properties of a DisconnectRequest.
             * @memberof rings_node
             * @interface IDisconnectRequest
             * @property {string|null} [did] DisconnectRequest did
             */
    
            /**
             * Constructs a new DisconnectRequest.
             * @memberof rings_node
             * @classdesc Represents a DisconnectRequest.
             * @implements IDisconnectRequest
             * @constructor
             * @param {rings_node.IDisconnectRequest=} [properties] Properties to set
             */
            function DisconnectRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DisconnectRequest did.
             * @member {string} did
             * @memberof rings_node.DisconnectRequest
             * @instance
             */
            DisconnectRequest.prototype.did = "";
    
            /**
             * Creates a new DisconnectRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {rings_node.IDisconnectRequest=} [properties] Properties to set
             * @returns {rings_node.DisconnectRequest} DisconnectRequest instance
             */
            DisconnectRequest.create = function create(properties) {
                return new DisconnectRequest(properties);
            };
    
            /**
             * Encodes the specified DisconnectRequest message. Does not implicitly {@link rings_node.DisconnectRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {rings_node.IDisconnectRequest} message DisconnectRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisconnectRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                return writer;
            };
    
            /**
             * Encodes the specified DisconnectRequest message, length delimited. Does not implicitly {@link rings_node.DisconnectRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {rings_node.IDisconnectRequest} message DisconnectRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisconnectRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DisconnectRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.DisconnectRequest} DisconnectRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisconnectRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.DisconnectRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DisconnectRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.DisconnectRequest} DisconnectRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisconnectRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DisconnectRequest message.
             * @function verify
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DisconnectRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                return null;
            };
    
            /**
             * Creates a DisconnectRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.DisconnectRequest} DisconnectRequest
             */
            DisconnectRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.DisconnectRequest)
                    return object;
                var message = new $root.rings_node.DisconnectRequest();
                if (object.did != null)
                    message.did = String(object.did);
                return message;
            };
    
            /**
             * Creates a plain object from a DisconnectRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {rings_node.DisconnectRequest} message DisconnectRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisconnectRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.did = "";
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                return object;
            };
    
            /**
             * Converts this DisconnectRequest to JSON.
             * @function toJSON
             * @memberof rings_node.DisconnectRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DisconnectRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for DisconnectRequest
             * @function getTypeUrl
             * @memberof rings_node.DisconnectRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DisconnectRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.DisconnectRequest";
            };
    
            return DisconnectRequest;
        })();
    
        rings_node.DisconnectResponse = (function() {
    
            /**
             * Properties of a DisconnectResponse.
             * @memberof rings_node
             * @interface IDisconnectResponse
             */
    
            /**
             * Constructs a new DisconnectResponse.
             * @memberof rings_node
             * @classdesc Represents a DisconnectResponse.
             * @implements IDisconnectResponse
             * @constructor
             * @param {rings_node.IDisconnectResponse=} [properties] Properties to set
             */
            function DisconnectResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new DisconnectResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {rings_node.IDisconnectResponse=} [properties] Properties to set
             * @returns {rings_node.DisconnectResponse} DisconnectResponse instance
             */
            DisconnectResponse.create = function create(properties) {
                return new DisconnectResponse(properties);
            };
    
            /**
             * Encodes the specified DisconnectResponse message. Does not implicitly {@link rings_node.DisconnectResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {rings_node.IDisconnectResponse} message DisconnectResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisconnectResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified DisconnectResponse message, length delimited. Does not implicitly {@link rings_node.DisconnectResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {rings_node.IDisconnectResponse} message DisconnectResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisconnectResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DisconnectResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.DisconnectResponse} DisconnectResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisconnectResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.DisconnectResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DisconnectResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.DisconnectResponse} DisconnectResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisconnectResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DisconnectResponse message.
             * @function verify
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DisconnectResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a DisconnectResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.DisconnectResponse} DisconnectResponse
             */
            DisconnectResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.DisconnectResponse)
                    return object;
                return new $root.rings_node.DisconnectResponse();
            };
    
            /**
             * Creates a plain object from a DisconnectResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {rings_node.DisconnectResponse} message DisconnectResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisconnectResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this DisconnectResponse to JSON.
             * @function toJSON
             * @memberof rings_node.DisconnectResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DisconnectResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for DisconnectResponse
             * @function getTypeUrl
             * @memberof rings_node.DisconnectResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DisconnectResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.DisconnectResponse";
            };
    
            return DisconnectResponse;
        })();
    
        rings_node.SendCustomMessageRequest = (function() {
    
            /**
             * Properties of a SendCustomMessageRequest.
             * @memberof rings_node
             * @interface ISendCustomMessageRequest
             * @property {string|null} [destination_did] SendCustomMessageRequest destination_did
             * @property {string|null} [data] SendCustomMessageRequest data
             */
    
            /**
             * Constructs a new SendCustomMessageRequest.
             * @memberof rings_node
             * @classdesc Represents a SendCustomMessageRequest.
             * @implements ISendCustomMessageRequest
             * @constructor
             * @param {rings_node.ISendCustomMessageRequest=} [properties] Properties to set
             */
            function SendCustomMessageRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SendCustomMessageRequest destination_did.
             * @member {string} destination_did
             * @memberof rings_node.SendCustomMessageRequest
             * @instance
             */
            SendCustomMessageRequest.prototype.destination_did = "";
    
            /**
             * SendCustomMessageRequest data.
             * @member {string} data
             * @memberof rings_node.SendCustomMessageRequest
             * @instance
             */
            SendCustomMessageRequest.prototype.data = "";
    
            /**
             * Creates a new SendCustomMessageRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {rings_node.ISendCustomMessageRequest=} [properties] Properties to set
             * @returns {rings_node.SendCustomMessageRequest} SendCustomMessageRequest instance
             */
            SendCustomMessageRequest.create = function create(properties) {
                return new SendCustomMessageRequest(properties);
            };
    
            /**
             * Encodes the specified SendCustomMessageRequest message. Does not implicitly {@link rings_node.SendCustomMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {rings_node.ISendCustomMessageRequest} message SendCustomMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendCustomMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destination_did != null && Object.hasOwnProperty.call(message, "destination_did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination_did);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified SendCustomMessageRequest message, length delimited. Does not implicitly {@link rings_node.SendCustomMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {rings_node.ISendCustomMessageRequest} message SendCustomMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendCustomMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SendCustomMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.SendCustomMessageRequest} SendCustomMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendCustomMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.SendCustomMessageRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.destination_did = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SendCustomMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.SendCustomMessageRequest} SendCustomMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendCustomMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SendCustomMessageRequest message.
             * @function verify
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendCustomMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destination_did != null && message.hasOwnProperty("destination_did"))
                    if (!$util.isString(message.destination_did))
                        return "destination_did: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };
    
            /**
             * Creates a SendCustomMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.SendCustomMessageRequest} SendCustomMessageRequest
             */
            SendCustomMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.SendCustomMessageRequest)
                    return object;
                var message = new $root.rings_node.SendCustomMessageRequest();
                if (object.destination_did != null)
                    message.destination_did = String(object.destination_did);
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };
    
            /**
             * Creates a plain object from a SendCustomMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {rings_node.SendCustomMessageRequest} message SendCustomMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendCustomMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destination_did = "";
                    object.data = "";
                }
                if (message.destination_did != null && message.hasOwnProperty("destination_did"))
                    object.destination_did = message.destination_did;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };
    
            /**
             * Converts this SendCustomMessageRequest to JSON.
             * @function toJSON
             * @memberof rings_node.SendCustomMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendCustomMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SendCustomMessageRequest
             * @function getTypeUrl
             * @memberof rings_node.SendCustomMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendCustomMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.SendCustomMessageRequest";
            };
    
            return SendCustomMessageRequest;
        })();
    
        rings_node.SendCustomMessageResponse = (function() {
    
            /**
             * Properties of a SendCustomMessageResponse.
             * @memberof rings_node
             * @interface ISendCustomMessageResponse
             */
    
            /**
             * Constructs a new SendCustomMessageResponse.
             * @memberof rings_node
             * @classdesc Represents a SendCustomMessageResponse.
             * @implements ISendCustomMessageResponse
             * @constructor
             * @param {rings_node.ISendCustomMessageResponse=} [properties] Properties to set
             */
            function SendCustomMessageResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SendCustomMessageResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {rings_node.ISendCustomMessageResponse=} [properties] Properties to set
             * @returns {rings_node.SendCustomMessageResponse} SendCustomMessageResponse instance
             */
            SendCustomMessageResponse.create = function create(properties) {
                return new SendCustomMessageResponse(properties);
            };
    
            /**
             * Encodes the specified SendCustomMessageResponse message. Does not implicitly {@link rings_node.SendCustomMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {rings_node.ISendCustomMessageResponse} message SendCustomMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendCustomMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SendCustomMessageResponse message, length delimited. Does not implicitly {@link rings_node.SendCustomMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {rings_node.ISendCustomMessageResponse} message SendCustomMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendCustomMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SendCustomMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.SendCustomMessageResponse} SendCustomMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendCustomMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.SendCustomMessageResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SendCustomMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.SendCustomMessageResponse} SendCustomMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendCustomMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SendCustomMessageResponse message.
             * @function verify
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendCustomMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SendCustomMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.SendCustomMessageResponse} SendCustomMessageResponse
             */
            SendCustomMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.SendCustomMessageResponse)
                    return object;
                return new $root.rings_node.SendCustomMessageResponse();
            };
    
            /**
             * Creates a plain object from a SendCustomMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {rings_node.SendCustomMessageResponse} message SendCustomMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendCustomMessageResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SendCustomMessageResponse to JSON.
             * @function toJSON
             * @memberof rings_node.SendCustomMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendCustomMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SendCustomMessageResponse
             * @function getTypeUrl
             * @memberof rings_node.SendCustomMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendCustomMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.SendCustomMessageResponse";
            };
    
            return SendCustomMessageResponse;
        })();
    
        rings_node.SendBackendMessageRequest = (function() {
    
            /**
             * Properties of a SendBackendMessageRequest.
             * @memberof rings_node
             * @interface ISendBackendMessageRequest
             * @property {string|null} [destination_did] SendBackendMessageRequest destination_did
             * @property {string|null} [data] SendBackendMessageRequest data
             */
    
            /**
             * Constructs a new SendBackendMessageRequest.
             * @memberof rings_node
             * @classdesc Represents a SendBackendMessageRequest.
             * @implements ISendBackendMessageRequest
             * @constructor
             * @param {rings_node.ISendBackendMessageRequest=} [properties] Properties to set
             */
            function SendBackendMessageRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SendBackendMessageRequest destination_did.
             * @member {string} destination_did
             * @memberof rings_node.SendBackendMessageRequest
             * @instance
             */
            SendBackendMessageRequest.prototype.destination_did = "";
    
            /**
             * SendBackendMessageRequest data.
             * @member {string} data
             * @memberof rings_node.SendBackendMessageRequest
             * @instance
             */
            SendBackendMessageRequest.prototype.data = "";
    
            /**
             * Creates a new SendBackendMessageRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {rings_node.ISendBackendMessageRequest=} [properties] Properties to set
             * @returns {rings_node.SendBackendMessageRequest} SendBackendMessageRequest instance
             */
            SendBackendMessageRequest.create = function create(properties) {
                return new SendBackendMessageRequest(properties);
            };
    
            /**
             * Encodes the specified SendBackendMessageRequest message. Does not implicitly {@link rings_node.SendBackendMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {rings_node.ISendBackendMessageRequest} message SendBackendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendBackendMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destination_did != null && Object.hasOwnProperty.call(message, "destination_did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination_did);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified SendBackendMessageRequest message, length delimited. Does not implicitly {@link rings_node.SendBackendMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {rings_node.ISendBackendMessageRequest} message SendBackendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendBackendMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SendBackendMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.SendBackendMessageRequest} SendBackendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendBackendMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.SendBackendMessageRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.destination_did = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SendBackendMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.SendBackendMessageRequest} SendBackendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendBackendMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SendBackendMessageRequest message.
             * @function verify
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendBackendMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destination_did != null && message.hasOwnProperty("destination_did"))
                    if (!$util.isString(message.destination_did))
                        return "destination_did: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };
    
            /**
             * Creates a SendBackendMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.SendBackendMessageRequest} SendBackendMessageRequest
             */
            SendBackendMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.SendBackendMessageRequest)
                    return object;
                var message = new $root.rings_node.SendBackendMessageRequest();
                if (object.destination_did != null)
                    message.destination_did = String(object.destination_did);
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };
    
            /**
             * Creates a plain object from a SendBackendMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {rings_node.SendBackendMessageRequest} message SendBackendMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendBackendMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destination_did = "";
                    object.data = "";
                }
                if (message.destination_did != null && message.hasOwnProperty("destination_did"))
                    object.destination_did = message.destination_did;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };
    
            /**
             * Converts this SendBackendMessageRequest to JSON.
             * @function toJSON
             * @memberof rings_node.SendBackendMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendBackendMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SendBackendMessageRequest
             * @function getTypeUrl
             * @memberof rings_node.SendBackendMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendBackendMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.SendBackendMessageRequest";
            };
    
            return SendBackendMessageRequest;
        })();
    
        rings_node.SendBackendMessageResponse = (function() {
    
            /**
             * Properties of a SendBackendMessageResponse.
             * @memberof rings_node
             * @interface ISendBackendMessageResponse
             */
    
            /**
             * Constructs a new SendBackendMessageResponse.
             * @memberof rings_node
             * @classdesc Represents a SendBackendMessageResponse.
             * @implements ISendBackendMessageResponse
             * @constructor
             * @param {rings_node.ISendBackendMessageResponse=} [properties] Properties to set
             */
            function SendBackendMessageResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SendBackendMessageResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {rings_node.ISendBackendMessageResponse=} [properties] Properties to set
             * @returns {rings_node.SendBackendMessageResponse} SendBackendMessageResponse instance
             */
            SendBackendMessageResponse.create = function create(properties) {
                return new SendBackendMessageResponse(properties);
            };
    
            /**
             * Encodes the specified SendBackendMessageResponse message. Does not implicitly {@link rings_node.SendBackendMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {rings_node.ISendBackendMessageResponse} message SendBackendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendBackendMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SendBackendMessageResponse message, length delimited. Does not implicitly {@link rings_node.SendBackendMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {rings_node.ISendBackendMessageResponse} message SendBackendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendBackendMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SendBackendMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.SendBackendMessageResponse} SendBackendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendBackendMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.SendBackendMessageResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SendBackendMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.SendBackendMessageResponse} SendBackendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendBackendMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SendBackendMessageResponse message.
             * @function verify
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendBackendMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SendBackendMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.SendBackendMessageResponse} SendBackendMessageResponse
             */
            SendBackendMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.SendBackendMessageResponse)
                    return object;
                return new $root.rings_node.SendBackendMessageResponse();
            };
    
            /**
             * Creates a plain object from a SendBackendMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {rings_node.SendBackendMessageResponse} message SendBackendMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendBackendMessageResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SendBackendMessageResponse to JSON.
             * @function toJSON
             * @memberof rings_node.SendBackendMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendBackendMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SendBackendMessageResponse
             * @function getTypeUrl
             * @memberof rings_node.SendBackendMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendBackendMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.SendBackendMessageResponse";
            };
    
            return SendBackendMessageResponse;
        })();
    
        rings_node.PublishMessageToTopicRequest = (function() {
    
            /**
             * Properties of a PublishMessageToTopicRequest.
             * @memberof rings_node
             * @interface IPublishMessageToTopicRequest
             * @property {string|null} [topic] PublishMessageToTopicRequest topic
             * @property {string|null} [data] PublishMessageToTopicRequest data
             */
    
            /**
             * Constructs a new PublishMessageToTopicRequest.
             * @memberof rings_node
             * @classdesc Represents a PublishMessageToTopicRequest.
             * @implements IPublishMessageToTopicRequest
             * @constructor
             * @param {rings_node.IPublishMessageToTopicRequest=} [properties] Properties to set
             */
            function PublishMessageToTopicRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PublishMessageToTopicRequest topic.
             * @member {string} topic
             * @memberof rings_node.PublishMessageToTopicRequest
             * @instance
             */
            PublishMessageToTopicRequest.prototype.topic = "";
    
            /**
             * PublishMessageToTopicRequest data.
             * @member {string} data
             * @memberof rings_node.PublishMessageToTopicRequest
             * @instance
             */
            PublishMessageToTopicRequest.prototype.data = "";
    
            /**
             * Creates a new PublishMessageToTopicRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {rings_node.IPublishMessageToTopicRequest=} [properties] Properties to set
             * @returns {rings_node.PublishMessageToTopicRequest} PublishMessageToTopicRequest instance
             */
            PublishMessageToTopicRequest.create = function create(properties) {
                return new PublishMessageToTopicRequest(properties);
            };
    
            /**
             * Encodes the specified PublishMessageToTopicRequest message. Does not implicitly {@link rings_node.PublishMessageToTopicRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {rings_node.IPublishMessageToTopicRequest} message PublishMessageToTopicRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishMessageToTopicRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified PublishMessageToTopicRequest message, length delimited. Does not implicitly {@link rings_node.PublishMessageToTopicRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {rings_node.IPublishMessageToTopicRequest} message PublishMessageToTopicRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishMessageToTopicRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PublishMessageToTopicRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.PublishMessageToTopicRequest} PublishMessageToTopicRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishMessageToTopicRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.PublishMessageToTopicRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.topic = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PublishMessageToTopicRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.PublishMessageToTopicRequest} PublishMessageToTopicRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishMessageToTopicRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PublishMessageToTopicRequest message.
             * @function verify
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PublishMessageToTopicRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };
    
            /**
             * Creates a PublishMessageToTopicRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.PublishMessageToTopicRequest} PublishMessageToTopicRequest
             */
            PublishMessageToTopicRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.PublishMessageToTopicRequest)
                    return object;
                var message = new $root.rings_node.PublishMessageToTopicRequest();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };
    
            /**
             * Creates a plain object from a PublishMessageToTopicRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {rings_node.PublishMessageToTopicRequest} message PublishMessageToTopicRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PublishMessageToTopicRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.data = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };
    
            /**
             * Converts this PublishMessageToTopicRequest to JSON.
             * @function toJSON
             * @memberof rings_node.PublishMessageToTopicRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PublishMessageToTopicRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for PublishMessageToTopicRequest
             * @function getTypeUrl
             * @memberof rings_node.PublishMessageToTopicRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PublishMessageToTopicRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.PublishMessageToTopicRequest";
            };
    
            return PublishMessageToTopicRequest;
        })();
    
        rings_node.PublishMessageToTopicResponse = (function() {
    
            /**
             * Properties of a PublishMessageToTopicResponse.
             * @memberof rings_node
             * @interface IPublishMessageToTopicResponse
             */
    
            /**
             * Constructs a new PublishMessageToTopicResponse.
             * @memberof rings_node
             * @classdesc Represents a PublishMessageToTopicResponse.
             * @implements IPublishMessageToTopicResponse
             * @constructor
             * @param {rings_node.IPublishMessageToTopicResponse=} [properties] Properties to set
             */
            function PublishMessageToTopicResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PublishMessageToTopicResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {rings_node.IPublishMessageToTopicResponse=} [properties] Properties to set
             * @returns {rings_node.PublishMessageToTopicResponse} PublishMessageToTopicResponse instance
             */
            PublishMessageToTopicResponse.create = function create(properties) {
                return new PublishMessageToTopicResponse(properties);
            };
    
            /**
             * Encodes the specified PublishMessageToTopicResponse message. Does not implicitly {@link rings_node.PublishMessageToTopicResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {rings_node.IPublishMessageToTopicResponse} message PublishMessageToTopicResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishMessageToTopicResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified PublishMessageToTopicResponse message, length delimited. Does not implicitly {@link rings_node.PublishMessageToTopicResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {rings_node.IPublishMessageToTopicResponse} message PublishMessageToTopicResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishMessageToTopicResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PublishMessageToTopicResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.PublishMessageToTopicResponse} PublishMessageToTopicResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishMessageToTopicResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.PublishMessageToTopicResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PublishMessageToTopicResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.PublishMessageToTopicResponse} PublishMessageToTopicResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishMessageToTopicResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PublishMessageToTopicResponse message.
             * @function verify
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PublishMessageToTopicResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a PublishMessageToTopicResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.PublishMessageToTopicResponse} PublishMessageToTopicResponse
             */
            PublishMessageToTopicResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.PublishMessageToTopicResponse)
                    return object;
                return new $root.rings_node.PublishMessageToTopicResponse();
            };
    
            /**
             * Creates a plain object from a PublishMessageToTopicResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {rings_node.PublishMessageToTopicResponse} message PublishMessageToTopicResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PublishMessageToTopicResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this PublishMessageToTopicResponse to JSON.
             * @function toJSON
             * @memberof rings_node.PublishMessageToTopicResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PublishMessageToTopicResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for PublishMessageToTopicResponse
             * @function getTypeUrl
             * @memberof rings_node.PublishMessageToTopicResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PublishMessageToTopicResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.PublishMessageToTopicResponse";
            };
    
            return PublishMessageToTopicResponse;
        })();
    
        rings_node.FetchTopicMessagesRequest = (function() {
    
            /**
             * Properties of a FetchTopicMessagesRequest.
             * @memberof rings_node
             * @interface IFetchTopicMessagesRequest
             * @property {string|null} [topic] FetchTopicMessagesRequest topic
             * @property {number|Long|null} [skip] FetchTopicMessagesRequest skip
             */
    
            /**
             * Constructs a new FetchTopicMessagesRequest.
             * @memberof rings_node
             * @classdesc Represents a FetchTopicMessagesRequest.
             * @implements IFetchTopicMessagesRequest
             * @constructor
             * @param {rings_node.IFetchTopicMessagesRequest=} [properties] Properties to set
             */
            function FetchTopicMessagesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FetchTopicMessagesRequest topic.
             * @member {string} topic
             * @memberof rings_node.FetchTopicMessagesRequest
             * @instance
             */
            FetchTopicMessagesRequest.prototype.topic = "";
    
            /**
             * FetchTopicMessagesRequest skip.
             * @member {number|Long} skip
             * @memberof rings_node.FetchTopicMessagesRequest
             * @instance
             */
            FetchTopicMessagesRequest.prototype.skip = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new FetchTopicMessagesRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {rings_node.IFetchTopicMessagesRequest=} [properties] Properties to set
             * @returns {rings_node.FetchTopicMessagesRequest} FetchTopicMessagesRequest instance
             */
            FetchTopicMessagesRequest.create = function create(properties) {
                return new FetchTopicMessagesRequest(properties);
            };
    
            /**
             * Encodes the specified FetchTopicMessagesRequest message. Does not implicitly {@link rings_node.FetchTopicMessagesRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {rings_node.IFetchTopicMessagesRequest} message FetchTopicMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchTopicMessagesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.skip != null && Object.hasOwnProperty.call(message, "skip"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.skip);
                return writer;
            };
    
            /**
             * Encodes the specified FetchTopicMessagesRequest message, length delimited. Does not implicitly {@link rings_node.FetchTopicMessagesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {rings_node.IFetchTopicMessagesRequest} message FetchTopicMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchTopicMessagesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FetchTopicMessagesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.FetchTopicMessagesRequest} FetchTopicMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchTopicMessagesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.FetchTopicMessagesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.topic = reader.string();
                            break;
                        }
                    case 2: {
                            message.skip = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FetchTopicMessagesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.FetchTopicMessagesRequest} FetchTopicMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchTopicMessagesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FetchTopicMessagesRequest message.
             * @function verify
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FetchTopicMessagesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.skip != null && message.hasOwnProperty("skip"))
                    if (!$util.isInteger(message.skip) && !(message.skip && $util.isInteger(message.skip.low) && $util.isInteger(message.skip.high)))
                        return "skip: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a FetchTopicMessagesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.FetchTopicMessagesRequest} FetchTopicMessagesRequest
             */
            FetchTopicMessagesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.FetchTopicMessagesRequest)
                    return object;
                var message = new $root.rings_node.FetchTopicMessagesRequest();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.skip != null)
                    if ($util.Long)
                        (message.skip = $util.Long.fromValue(object.skip)).unsigned = false;
                    else if (typeof object.skip === "string")
                        message.skip = parseInt(object.skip, 10);
                    else if (typeof object.skip === "number")
                        message.skip = object.skip;
                    else if (typeof object.skip === "object")
                        message.skip = new $util.LongBits(object.skip.low >>> 0, object.skip.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a FetchTopicMessagesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {rings_node.FetchTopicMessagesRequest} message FetchTopicMessagesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FetchTopicMessagesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.skip = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.skip = options.longs === String ? "0" : 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.skip != null && message.hasOwnProperty("skip"))
                    if (typeof message.skip === "number")
                        object.skip = options.longs === String ? String(message.skip) : message.skip;
                    else
                        object.skip = options.longs === String ? $util.Long.prototype.toString.call(message.skip) : options.longs === Number ? new $util.LongBits(message.skip.low >>> 0, message.skip.high >>> 0).toNumber() : message.skip;
                return object;
            };
    
            /**
             * Converts this FetchTopicMessagesRequest to JSON.
             * @function toJSON
             * @memberof rings_node.FetchTopicMessagesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FetchTopicMessagesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for FetchTopicMessagesRequest
             * @function getTypeUrl
             * @memberof rings_node.FetchTopicMessagesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FetchTopicMessagesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.FetchTopicMessagesRequest";
            };
    
            return FetchTopicMessagesRequest;
        })();
    
        rings_node.FetchTopicMessagesResponse = (function() {
    
            /**
             * Properties of a FetchTopicMessagesResponse.
             * @memberof rings_node
             * @interface IFetchTopicMessagesResponse
             * @property {Array.<string>|null} [data] FetchTopicMessagesResponse data
             */
    
            /**
             * Constructs a new FetchTopicMessagesResponse.
             * @memberof rings_node
             * @classdesc Represents a FetchTopicMessagesResponse.
             * @implements IFetchTopicMessagesResponse
             * @constructor
             * @param {rings_node.IFetchTopicMessagesResponse=} [properties] Properties to set
             */
            function FetchTopicMessagesResponse(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FetchTopicMessagesResponse data.
             * @member {Array.<string>} data
             * @memberof rings_node.FetchTopicMessagesResponse
             * @instance
             */
            FetchTopicMessagesResponse.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new FetchTopicMessagesResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {rings_node.IFetchTopicMessagesResponse=} [properties] Properties to set
             * @returns {rings_node.FetchTopicMessagesResponse} FetchTopicMessagesResponse instance
             */
            FetchTopicMessagesResponse.create = function create(properties) {
                return new FetchTopicMessagesResponse(properties);
            };
    
            /**
             * Encodes the specified FetchTopicMessagesResponse message. Does not implicitly {@link rings_node.FetchTopicMessagesResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {rings_node.IFetchTopicMessagesResponse} message FetchTopicMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchTopicMessagesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.data[i]);
                return writer;
            };
    
            /**
             * Encodes the specified FetchTopicMessagesResponse message, length delimited. Does not implicitly {@link rings_node.FetchTopicMessagesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {rings_node.IFetchTopicMessagesResponse} message FetchTopicMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchTopicMessagesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FetchTopicMessagesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.FetchTopicMessagesResponse} FetchTopicMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchTopicMessagesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.FetchTopicMessagesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.data && message.data.length))
                                message.data = [];
                            message.data.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FetchTopicMessagesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.FetchTopicMessagesResponse} FetchTopicMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchTopicMessagesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FetchTopicMessagesResponse message.
             * @function verify
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FetchTopicMessagesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isString(message.data[i]))
                            return "data: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a FetchTopicMessagesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.FetchTopicMessagesResponse} FetchTopicMessagesResponse
             */
            FetchTopicMessagesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.FetchTopicMessagesResponse)
                    return object;
                var message = new $root.rings_node.FetchTopicMessagesResponse();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".rings_node.FetchTopicMessagesResponse.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = String(object.data[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FetchTopicMessagesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {rings_node.FetchTopicMessagesResponse} message FetchTopicMessagesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FetchTopicMessagesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this FetchTopicMessagesResponse to JSON.
             * @function toJSON
             * @memberof rings_node.FetchTopicMessagesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FetchTopicMessagesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for FetchTopicMessagesResponse
             * @function getTypeUrl
             * @memberof rings_node.FetchTopicMessagesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FetchTopicMessagesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.FetchTopicMessagesResponse";
            };
    
            return FetchTopicMessagesResponse;
        })();
    
        rings_node.RegisterServiceRequest = (function() {
    
            /**
             * Properties of a RegisterServiceRequest.
             * @memberof rings_node
             * @interface IRegisterServiceRequest
             * @property {string|null} [name] RegisterServiceRequest name
             */
    
            /**
             * Constructs a new RegisterServiceRequest.
             * @memberof rings_node
             * @classdesc Represents a RegisterServiceRequest.
             * @implements IRegisterServiceRequest
             * @constructor
             * @param {rings_node.IRegisterServiceRequest=} [properties] Properties to set
             */
            function RegisterServiceRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RegisterServiceRequest name.
             * @member {string} name
             * @memberof rings_node.RegisterServiceRequest
             * @instance
             */
            RegisterServiceRequest.prototype.name = "";
    
            /**
             * Creates a new RegisterServiceRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {rings_node.IRegisterServiceRequest=} [properties] Properties to set
             * @returns {rings_node.RegisterServiceRequest} RegisterServiceRequest instance
             */
            RegisterServiceRequest.create = function create(properties) {
                return new RegisterServiceRequest(properties);
            };
    
            /**
             * Encodes the specified RegisterServiceRequest message. Does not implicitly {@link rings_node.RegisterServiceRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {rings_node.IRegisterServiceRequest} message RegisterServiceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegisterServiceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified RegisterServiceRequest message, length delimited. Does not implicitly {@link rings_node.RegisterServiceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {rings_node.IRegisterServiceRequest} message RegisterServiceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegisterServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RegisterServiceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.RegisterServiceRequest} RegisterServiceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegisterServiceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.RegisterServiceRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RegisterServiceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.RegisterServiceRequest} RegisterServiceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegisterServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RegisterServiceRequest message.
             * @function verify
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RegisterServiceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a RegisterServiceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.RegisterServiceRequest} RegisterServiceRequest
             */
            RegisterServiceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.RegisterServiceRequest)
                    return object;
                var message = new $root.rings_node.RegisterServiceRequest();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a RegisterServiceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {rings_node.RegisterServiceRequest} message RegisterServiceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RegisterServiceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this RegisterServiceRequest to JSON.
             * @function toJSON
             * @memberof rings_node.RegisterServiceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RegisterServiceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for RegisterServiceRequest
             * @function getTypeUrl
             * @memberof rings_node.RegisterServiceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RegisterServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.RegisterServiceRequest";
            };
    
            return RegisterServiceRequest;
        })();
    
        rings_node.RegisterServiceResponse = (function() {
    
            /**
             * Properties of a RegisterServiceResponse.
             * @memberof rings_node
             * @interface IRegisterServiceResponse
             */
    
            /**
             * Constructs a new RegisterServiceResponse.
             * @memberof rings_node
             * @classdesc Represents a RegisterServiceResponse.
             * @implements IRegisterServiceResponse
             * @constructor
             * @param {rings_node.IRegisterServiceResponse=} [properties] Properties to set
             */
            function RegisterServiceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RegisterServiceResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {rings_node.IRegisterServiceResponse=} [properties] Properties to set
             * @returns {rings_node.RegisterServiceResponse} RegisterServiceResponse instance
             */
            RegisterServiceResponse.create = function create(properties) {
                return new RegisterServiceResponse(properties);
            };
    
            /**
             * Encodes the specified RegisterServiceResponse message. Does not implicitly {@link rings_node.RegisterServiceResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {rings_node.IRegisterServiceResponse} message RegisterServiceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegisterServiceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified RegisterServiceResponse message, length delimited. Does not implicitly {@link rings_node.RegisterServiceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {rings_node.IRegisterServiceResponse} message RegisterServiceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegisterServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RegisterServiceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.RegisterServiceResponse} RegisterServiceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegisterServiceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.RegisterServiceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RegisterServiceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.RegisterServiceResponse} RegisterServiceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegisterServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RegisterServiceResponse message.
             * @function verify
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RegisterServiceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a RegisterServiceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.RegisterServiceResponse} RegisterServiceResponse
             */
            RegisterServiceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.RegisterServiceResponse)
                    return object;
                return new $root.rings_node.RegisterServiceResponse();
            };
    
            /**
             * Creates a plain object from a RegisterServiceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {rings_node.RegisterServiceResponse} message RegisterServiceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RegisterServiceResponse.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this RegisterServiceResponse to JSON.
             * @function toJSON
             * @memberof rings_node.RegisterServiceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RegisterServiceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for RegisterServiceResponse
             * @function getTypeUrl
             * @memberof rings_node.RegisterServiceResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RegisterServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.RegisterServiceResponse";
            };
    
            return RegisterServiceResponse;
        })();
    
        rings_node.LookupServiceRequest = (function() {
    
            /**
             * Properties of a LookupServiceRequest.
             * @memberof rings_node
             * @interface ILookupServiceRequest
             * @property {string|null} [name] LookupServiceRequest name
             */
    
            /**
             * Constructs a new LookupServiceRequest.
             * @memberof rings_node
             * @classdesc Represents a LookupServiceRequest.
             * @implements ILookupServiceRequest
             * @constructor
             * @param {rings_node.ILookupServiceRequest=} [properties] Properties to set
             */
            function LookupServiceRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LookupServiceRequest name.
             * @member {string} name
             * @memberof rings_node.LookupServiceRequest
             * @instance
             */
            LookupServiceRequest.prototype.name = "";
    
            /**
             * Creates a new LookupServiceRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {rings_node.ILookupServiceRequest=} [properties] Properties to set
             * @returns {rings_node.LookupServiceRequest} LookupServiceRequest instance
             */
            LookupServiceRequest.create = function create(properties) {
                return new LookupServiceRequest(properties);
            };
    
            /**
             * Encodes the specified LookupServiceRequest message. Does not implicitly {@link rings_node.LookupServiceRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {rings_node.ILookupServiceRequest} message LookupServiceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookupServiceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified LookupServiceRequest message, length delimited. Does not implicitly {@link rings_node.LookupServiceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {rings_node.ILookupServiceRequest} message LookupServiceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookupServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LookupServiceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.LookupServiceRequest} LookupServiceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookupServiceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.LookupServiceRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LookupServiceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.LookupServiceRequest} LookupServiceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookupServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LookupServiceRequest message.
             * @function verify
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LookupServiceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a LookupServiceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.LookupServiceRequest} LookupServiceRequest
             */
            LookupServiceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.LookupServiceRequest)
                    return object;
                var message = new $root.rings_node.LookupServiceRequest();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a LookupServiceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {rings_node.LookupServiceRequest} message LookupServiceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LookupServiceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this LookupServiceRequest to JSON.
             * @function toJSON
             * @memberof rings_node.LookupServiceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LookupServiceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for LookupServiceRequest
             * @function getTypeUrl
             * @memberof rings_node.LookupServiceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LookupServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.LookupServiceRequest";
            };
    
            return LookupServiceRequest;
        })();
    
        rings_node.LookupServiceResponse = (function() {
    
            /**
             * Properties of a LookupServiceResponse.
             * @memberof rings_node
             * @interface ILookupServiceResponse
             * @property {Array.<string>|null} [dids] LookupServiceResponse dids
             */
    
            /**
             * Constructs a new LookupServiceResponse.
             * @memberof rings_node
             * @classdesc Represents a LookupServiceResponse.
             * @implements ILookupServiceResponse
             * @constructor
             * @param {rings_node.ILookupServiceResponse=} [properties] Properties to set
             */
            function LookupServiceResponse(properties) {
                this.dids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LookupServiceResponse dids.
             * @member {Array.<string>} dids
             * @memberof rings_node.LookupServiceResponse
             * @instance
             */
            LookupServiceResponse.prototype.dids = $util.emptyArray;
    
            /**
             * Creates a new LookupServiceResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {rings_node.ILookupServiceResponse=} [properties] Properties to set
             * @returns {rings_node.LookupServiceResponse} LookupServiceResponse instance
             */
            LookupServiceResponse.create = function create(properties) {
                return new LookupServiceResponse(properties);
            };
    
            /**
             * Encodes the specified LookupServiceResponse message. Does not implicitly {@link rings_node.LookupServiceResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {rings_node.ILookupServiceResponse} message LookupServiceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookupServiceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dids != null && message.dids.length)
                    for (var i = 0; i < message.dids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.dids[i]);
                return writer;
            };
    
            /**
             * Encodes the specified LookupServiceResponse message, length delimited. Does not implicitly {@link rings_node.LookupServiceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {rings_node.ILookupServiceResponse} message LookupServiceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookupServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LookupServiceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.LookupServiceResponse} LookupServiceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookupServiceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.LookupServiceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.dids && message.dids.length))
                                message.dids = [];
                            message.dids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LookupServiceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.LookupServiceResponse} LookupServiceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookupServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LookupServiceResponse message.
             * @function verify
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LookupServiceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dids != null && message.hasOwnProperty("dids")) {
                    if (!Array.isArray(message.dids))
                        return "dids: array expected";
                    for (var i = 0; i < message.dids.length; ++i)
                        if (!$util.isString(message.dids[i]))
                            return "dids: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a LookupServiceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.LookupServiceResponse} LookupServiceResponse
             */
            LookupServiceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.LookupServiceResponse)
                    return object;
                var message = new $root.rings_node.LookupServiceResponse();
                if (object.dids) {
                    if (!Array.isArray(object.dids))
                        throw TypeError(".rings_node.LookupServiceResponse.dids: array expected");
                    message.dids = [];
                    for (var i = 0; i < object.dids.length; ++i)
                        message.dids[i] = String(object.dids[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a LookupServiceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {rings_node.LookupServiceResponse} message LookupServiceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LookupServiceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.dids = [];
                if (message.dids && message.dids.length) {
                    object.dids = [];
                    for (var j = 0; j < message.dids.length; ++j)
                        object.dids[j] = message.dids[j];
                }
                return object;
            };
    
            /**
             * Converts this LookupServiceResponse to JSON.
             * @function toJSON
             * @memberof rings_node.LookupServiceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LookupServiceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for LookupServiceResponse
             * @function getTypeUrl
             * @memberof rings_node.LookupServiceResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LookupServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.LookupServiceResponse";
            };
    
            return LookupServiceResponse;
        })();
    
        rings_node.NodeInfoRequest = (function() {
    
            /**
             * Properties of a NodeInfoRequest.
             * @memberof rings_node
             * @interface INodeInfoRequest
             */
    
            /**
             * Constructs a new NodeInfoRequest.
             * @memberof rings_node
             * @classdesc Represents a NodeInfoRequest.
             * @implements INodeInfoRequest
             * @constructor
             * @param {rings_node.INodeInfoRequest=} [properties] Properties to set
             */
            function NodeInfoRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new NodeInfoRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {rings_node.INodeInfoRequest=} [properties] Properties to set
             * @returns {rings_node.NodeInfoRequest} NodeInfoRequest instance
             */
            NodeInfoRequest.create = function create(properties) {
                return new NodeInfoRequest(properties);
            };
    
            /**
             * Encodes the specified NodeInfoRequest message. Does not implicitly {@link rings_node.NodeInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {rings_node.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified NodeInfoRequest message, length delimited. Does not implicitly {@link rings_node.NodeInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {rings_node.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NodeInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.NodeInfoRequest} NodeInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.NodeInfoRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NodeInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.NodeInfoRequest} NodeInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NodeInfoRequest message.
             * @function verify
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a NodeInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.NodeInfoRequest} NodeInfoRequest
             */
            NodeInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.NodeInfoRequest)
                    return object;
                return new $root.rings_node.NodeInfoRequest();
            };
    
            /**
             * Creates a plain object from a NodeInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {rings_node.NodeInfoRequest} message NodeInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeInfoRequest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this NodeInfoRequest to JSON.
             * @function toJSON
             * @memberof rings_node.NodeInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for NodeInfoRequest
             * @function getTypeUrl
             * @memberof rings_node.NodeInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.NodeInfoRequest";
            };
    
            return NodeInfoRequest;
        })();
    
        rings_node.FingerTableRange = (function() {
    
            /**
             * Properties of a FingerTableRange.
             * @memberof rings_node
             * @interface IFingerTableRange
             * @property {string|null} [did] FingerTableRange did
             * @property {number|Long|null} [start] FingerTableRange start
             * @property {number|Long|null} [end] FingerTableRange end
             */
    
            /**
             * Constructs a new FingerTableRange.
             * @memberof rings_node
             * @classdesc Represents a FingerTableRange.
             * @implements IFingerTableRange
             * @constructor
             * @param {rings_node.IFingerTableRange=} [properties] Properties to set
             */
            function FingerTableRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FingerTableRange did.
             * @member {string|null|undefined} did
             * @memberof rings_node.FingerTableRange
             * @instance
             */
            FingerTableRange.prototype.did = null;
    
            /**
             * FingerTableRange start.
             * @member {number|Long} start
             * @memberof rings_node.FingerTableRange
             * @instance
             */
            FingerTableRange.prototype.start = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * FingerTableRange end.
             * @member {number|Long} end
             * @memberof rings_node.FingerTableRange
             * @instance
             */
            FingerTableRange.prototype.end = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * FingerTableRange _did.
             * @member {"did"|undefined} _did
             * @memberof rings_node.FingerTableRange
             * @instance
             */
            Object.defineProperty(FingerTableRange.prototype, "_did", {
                get: $util.oneOfGetter($oneOfFields = ["did"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new FingerTableRange instance using the specified properties.
             * @function create
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {rings_node.IFingerTableRange=} [properties] Properties to set
             * @returns {rings_node.FingerTableRange} FingerTableRange instance
             */
            FingerTableRange.create = function create(properties) {
                return new FingerTableRange(properties);
            };
    
            /**
             * Encodes the specified FingerTableRange message. Does not implicitly {@link rings_node.FingerTableRange.verify|verify} messages.
             * @function encode
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {rings_node.IFingerTableRange} message FingerTableRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FingerTableRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.start);
                if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.end);
                return writer;
            };
    
            /**
             * Encodes the specified FingerTableRange message, length delimited. Does not implicitly {@link rings_node.FingerTableRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {rings_node.IFingerTableRange} message FingerTableRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FingerTableRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FingerTableRange message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.FingerTableRange} FingerTableRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FingerTableRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.FingerTableRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    case 2: {
                            message.start = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.end = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FingerTableRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.FingerTableRange} FingerTableRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FingerTableRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FingerTableRange message.
             * @function verify
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FingerTableRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.did != null && message.hasOwnProperty("did")) {
                    properties._did = 1;
                    if (!$util.isString(message.did))
                        return "did: string expected";
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                        return "start: integer|Long expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                        return "end: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a FingerTableRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.FingerTableRange} FingerTableRange
             */
            FingerTableRange.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.FingerTableRange)
                    return object;
                var message = new $root.rings_node.FingerTableRange();
                if (object.did != null)
                    message.did = String(object.did);
                if (object.start != null)
                    if ($util.Long)
                        (message.start = $util.Long.fromValue(object.start)).unsigned = true;
                    else if (typeof object.start === "string")
                        message.start = parseInt(object.start, 10);
                    else if (typeof object.start === "number")
                        message.start = object.start;
                    else if (typeof object.start === "object")
                        message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber(true);
                if (object.end != null)
                    if ($util.Long)
                        (message.end = $util.Long.fromValue(object.end)).unsigned = true;
                    else if (typeof object.end === "string")
                        message.end = parseInt(object.end, 10);
                    else if (typeof object.end === "number")
                        message.end = object.end;
                    else if (typeof object.end === "object")
                        message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a FingerTableRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {rings_node.FingerTableRange} message FingerTableRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FingerTableRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.start = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.end = options.longs === String ? "0" : 0;
                }
                if (message.did != null && message.hasOwnProperty("did")) {
                    object.did = message.did;
                    if (options.oneofs)
                        object._did = "did";
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    if (typeof message.start === "number")
                        object.start = options.longs === String ? String(message.start) : message.start;
                    else
                        object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber(true) : message.start;
                if (message.end != null && message.hasOwnProperty("end"))
                    if (typeof message.end === "number")
                        object.end = options.longs === String ? String(message.end) : message.end;
                    else
                        object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber(true) : message.end;
                return object;
            };
    
            /**
             * Converts this FingerTableRange to JSON.
             * @function toJSON
             * @memberof rings_node.FingerTableRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FingerTableRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for FingerTableRange
             * @function getTypeUrl
             * @memberof rings_node.FingerTableRange
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FingerTableRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.FingerTableRange";
            };
    
            return FingerTableRange;
        })();
    
        rings_node.DhtInfo = (function() {
    
            /**
             * Properties of a DhtInfo.
             * @memberof rings_node
             * @interface IDhtInfo
             * @property {string|null} [did] DhtInfo did
             * @property {Array.<string>|null} [successors] DhtInfo successors
             * @property {string|null} [predecessor] DhtInfo predecessor
             * @property {Array.<rings_node.IFingerTableRange>|null} [finger_table_ranges] DhtInfo finger_table_ranges
             */
    
            /**
             * Constructs a new DhtInfo.
             * @memberof rings_node
             * @classdesc Represents a DhtInfo.
             * @implements IDhtInfo
             * @constructor
             * @param {rings_node.IDhtInfo=} [properties] Properties to set
             */
            function DhtInfo(properties) {
                this.successors = [];
                this.finger_table_ranges = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DhtInfo did.
             * @member {string} did
             * @memberof rings_node.DhtInfo
             * @instance
             */
            DhtInfo.prototype.did = "";
    
            /**
             * DhtInfo successors.
             * @member {Array.<string>} successors
             * @memberof rings_node.DhtInfo
             * @instance
             */
            DhtInfo.prototype.successors = $util.emptyArray;
    
            /**
             * DhtInfo predecessor.
             * @member {string|null|undefined} predecessor
             * @memberof rings_node.DhtInfo
             * @instance
             */
            DhtInfo.prototype.predecessor = null;
    
            /**
             * DhtInfo finger_table_ranges.
             * @member {Array.<rings_node.IFingerTableRange>} finger_table_ranges
             * @memberof rings_node.DhtInfo
             * @instance
             */
            DhtInfo.prototype.finger_table_ranges = $util.emptyArray;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DhtInfo _predecessor.
             * @member {"predecessor"|undefined} _predecessor
             * @memberof rings_node.DhtInfo
             * @instance
             */
            Object.defineProperty(DhtInfo.prototype, "_predecessor", {
                get: $util.oneOfGetter($oneOfFields = ["predecessor"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DhtInfo instance using the specified properties.
             * @function create
             * @memberof rings_node.DhtInfo
             * @static
             * @param {rings_node.IDhtInfo=} [properties] Properties to set
             * @returns {rings_node.DhtInfo} DhtInfo instance
             */
            DhtInfo.create = function create(properties) {
                return new DhtInfo(properties);
            };
    
            /**
             * Encodes the specified DhtInfo message. Does not implicitly {@link rings_node.DhtInfo.verify|verify} messages.
             * @function encode
             * @memberof rings_node.DhtInfo
             * @static
             * @param {rings_node.IDhtInfo} message DhtInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DhtInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                if (message.successors != null && message.successors.length)
                    for (var i = 0; i < message.successors.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.successors[i]);
                if (message.predecessor != null && Object.hasOwnProperty.call(message, "predecessor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.predecessor);
                if (message.finger_table_ranges != null && message.finger_table_ranges.length)
                    for (var i = 0; i < message.finger_table_ranges.length; ++i)
                        $root.rings_node.FingerTableRange.encode(message.finger_table_ranges[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DhtInfo message, length delimited. Does not implicitly {@link rings_node.DhtInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.DhtInfo
             * @static
             * @param {rings_node.IDhtInfo} message DhtInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DhtInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DhtInfo message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.DhtInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.DhtInfo} DhtInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DhtInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.DhtInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.successors && message.successors.length))
                                message.successors = [];
                            message.successors.push(reader.string());
                            break;
                        }
                    case 3: {
                            message.predecessor = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.finger_table_ranges && message.finger_table_ranges.length))
                                message.finger_table_ranges = [];
                            message.finger_table_ranges.push($root.rings_node.FingerTableRange.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DhtInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.DhtInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.DhtInfo} DhtInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DhtInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DhtInfo message.
             * @function verify
             * @memberof rings_node.DhtInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DhtInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                if (message.successors != null && message.hasOwnProperty("successors")) {
                    if (!Array.isArray(message.successors))
                        return "successors: array expected";
                    for (var i = 0; i < message.successors.length; ++i)
                        if (!$util.isString(message.successors[i]))
                            return "successors: string[] expected";
                }
                if (message.predecessor != null && message.hasOwnProperty("predecessor")) {
                    properties._predecessor = 1;
                    if (!$util.isString(message.predecessor))
                        return "predecessor: string expected";
                }
                if (message.finger_table_ranges != null && message.hasOwnProperty("finger_table_ranges")) {
                    if (!Array.isArray(message.finger_table_ranges))
                        return "finger_table_ranges: array expected";
                    for (var i = 0; i < message.finger_table_ranges.length; ++i) {
                        var error = $root.rings_node.FingerTableRange.verify(message.finger_table_ranges[i]);
                        if (error)
                            return "finger_table_ranges." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DhtInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.DhtInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.DhtInfo} DhtInfo
             */
            DhtInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.DhtInfo)
                    return object;
                var message = new $root.rings_node.DhtInfo();
                if (object.did != null)
                    message.did = String(object.did);
                if (object.successors) {
                    if (!Array.isArray(object.successors))
                        throw TypeError(".rings_node.DhtInfo.successors: array expected");
                    message.successors = [];
                    for (var i = 0; i < object.successors.length; ++i)
                        message.successors[i] = String(object.successors[i]);
                }
                if (object.predecessor != null)
                    message.predecessor = String(object.predecessor);
                if (object.finger_table_ranges) {
                    if (!Array.isArray(object.finger_table_ranges))
                        throw TypeError(".rings_node.DhtInfo.finger_table_ranges: array expected");
                    message.finger_table_ranges = [];
                    for (var i = 0; i < object.finger_table_ranges.length; ++i) {
                        if (typeof object.finger_table_ranges[i] !== "object")
                            throw TypeError(".rings_node.DhtInfo.finger_table_ranges: object expected");
                        message.finger_table_ranges[i] = $root.rings_node.FingerTableRange.fromObject(object.finger_table_ranges[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DhtInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.DhtInfo
             * @static
             * @param {rings_node.DhtInfo} message DhtInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DhtInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.successors = [];
                    object.finger_table_ranges = [];
                }
                if (options.defaults)
                    object.did = "";
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                if (message.successors && message.successors.length) {
                    object.successors = [];
                    for (var j = 0; j < message.successors.length; ++j)
                        object.successors[j] = message.successors[j];
                }
                if (message.predecessor != null && message.hasOwnProperty("predecessor")) {
                    object.predecessor = message.predecessor;
                    if (options.oneofs)
                        object._predecessor = "predecessor";
                }
                if (message.finger_table_ranges && message.finger_table_ranges.length) {
                    object.finger_table_ranges = [];
                    for (var j = 0; j < message.finger_table_ranges.length; ++j)
                        object.finger_table_ranges[j] = $root.rings_node.FingerTableRange.toObject(message.finger_table_ranges[j], options);
                }
                return object;
            };
    
            /**
             * Converts this DhtInfo to JSON.
             * @function toJSON
             * @memberof rings_node.DhtInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DhtInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for DhtInfo
             * @function getTypeUrl
             * @memberof rings_node.DhtInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DhtInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.DhtInfo";
            };
    
            return DhtInfo;
        })();
    
        rings_node.StorageValue = (function() {
    
            /**
             * Properties of a StorageValue.
             * @memberof rings_node
             * @interface IStorageValue
             * @property {string|null} [did] StorageValue did
             * @property {string|null} [kind] StorageValue kind
             * @property {Array.<string>|null} [data] StorageValue data
             */
    
            /**
             * Constructs a new StorageValue.
             * @memberof rings_node
             * @classdesc Represents a StorageValue.
             * @implements IStorageValue
             * @constructor
             * @param {rings_node.IStorageValue=} [properties] Properties to set
             */
            function StorageValue(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StorageValue did.
             * @member {string} did
             * @memberof rings_node.StorageValue
             * @instance
             */
            StorageValue.prototype.did = "";
    
            /**
             * StorageValue kind.
             * @member {string} kind
             * @memberof rings_node.StorageValue
             * @instance
             */
            StorageValue.prototype.kind = "";
    
            /**
             * StorageValue data.
             * @member {Array.<string>} data
             * @memberof rings_node.StorageValue
             * @instance
             */
            StorageValue.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new StorageValue instance using the specified properties.
             * @function create
             * @memberof rings_node.StorageValue
             * @static
             * @param {rings_node.IStorageValue=} [properties] Properties to set
             * @returns {rings_node.StorageValue} StorageValue instance
             */
            StorageValue.create = function create(properties) {
                return new StorageValue(properties);
            };
    
            /**
             * Encodes the specified StorageValue message. Does not implicitly {@link rings_node.StorageValue.verify|verify} messages.
             * @function encode
             * @memberof rings_node.StorageValue
             * @static
             * @param {rings_node.IStorageValue} message StorageValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.kind);
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.data[i]);
                return writer;
            };
    
            /**
             * Encodes the specified StorageValue message, length delimited. Does not implicitly {@link rings_node.StorageValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.StorageValue
             * @static
             * @param {rings_node.IStorageValue} message StorageValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StorageValue message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.StorageValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.StorageValue} StorageValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.StorageValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    case 2: {
                            message.kind = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.data && message.data.length))
                                message.data = [];
                            message.data.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StorageValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.StorageValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.StorageValue} StorageValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StorageValue message.
             * @function verify
             * @memberof rings_node.StorageValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isString(message.data[i]))
                            return "data: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a StorageValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.StorageValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.StorageValue} StorageValue
             */
            StorageValue.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.StorageValue)
                    return object;
                var message = new $root.rings_node.StorageValue();
                if (object.did != null)
                    message.did = String(object.did);
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".rings_node.StorageValue.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = String(object.data[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StorageValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.StorageValue
             * @static
             * @param {rings_node.StorageValue} message StorageValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (options.defaults) {
                    object.did = "";
                    object.kind = "";
                }
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this StorageValue to JSON.
             * @function toJSON
             * @memberof rings_node.StorageValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for StorageValue
             * @function getTypeUrl
             * @memberof rings_node.StorageValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StorageValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.StorageValue";
            };
    
            return StorageValue;
        })();
    
        rings_node.StorageItem = (function() {
    
            /**
             * Properties of a StorageItem.
             * @memberof rings_node
             * @interface IStorageItem
             * @property {string|null} [key] StorageItem key
             * @property {rings_node.IStorageValue|null} [value] StorageItem value
             */
    
            /**
             * Constructs a new StorageItem.
             * @memberof rings_node
             * @classdesc Represents a StorageItem.
             * @implements IStorageItem
             * @constructor
             * @param {rings_node.IStorageItem=} [properties] Properties to set
             */
            function StorageItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StorageItem key.
             * @member {string} key
             * @memberof rings_node.StorageItem
             * @instance
             */
            StorageItem.prototype.key = "";
    
            /**
             * StorageItem value.
             * @member {rings_node.IStorageValue|null|undefined} value
             * @memberof rings_node.StorageItem
             * @instance
             */
            StorageItem.prototype.value = null;
    
            /**
             * Creates a new StorageItem instance using the specified properties.
             * @function create
             * @memberof rings_node.StorageItem
             * @static
             * @param {rings_node.IStorageItem=} [properties] Properties to set
             * @returns {rings_node.StorageItem} StorageItem instance
             */
            StorageItem.create = function create(properties) {
                return new StorageItem(properties);
            };
    
            /**
             * Encodes the specified StorageItem message. Does not implicitly {@link rings_node.StorageItem.verify|verify} messages.
             * @function encode
             * @memberof rings_node.StorageItem
             * @static
             * @param {rings_node.IStorageItem} message StorageItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    $root.rings_node.StorageValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StorageItem message, length delimited. Does not implicitly {@link rings_node.StorageItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.StorageItem
             * @static
             * @param {rings_node.IStorageItem} message StorageItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StorageItem message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.StorageItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.StorageItem} StorageItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.StorageItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = $root.rings_node.StorageValue.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StorageItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.StorageItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.StorageItem} StorageItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StorageItem message.
             * @function verify
             * @memberof rings_node.StorageItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    var error = $root.rings_node.StorageValue.verify(message.value);
                    if (error)
                        return "value." + error;
                }
                return null;
            };
    
            /**
             * Creates a StorageItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.StorageItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.StorageItem} StorageItem
             */
            StorageItem.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.StorageItem)
                    return object;
                var message = new $root.rings_node.StorageItem();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null) {
                    if (typeof object.value !== "object")
                        throw TypeError(".rings_node.StorageItem.value: object expected");
                    message.value = $root.rings_node.StorageValue.fromObject(object.value);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StorageItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.StorageItem
             * @static
             * @param {rings_node.StorageItem} message StorageItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = $root.rings_node.StorageValue.toObject(message.value, options);
                return object;
            };
    
            /**
             * Converts this StorageItem to JSON.
             * @function toJSON
             * @memberof rings_node.StorageItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for StorageItem
             * @function getTypeUrl
             * @memberof rings_node.StorageItem
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StorageItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.StorageItem";
            };
    
            return StorageItem;
        })();
    
        rings_node.StorageInfo = (function() {
    
            /**
             * Properties of a StorageInfo.
             * @memberof rings_node
             * @interface IStorageInfo
             * @property {Array.<rings_node.IStorageItem>|null} [items] StorageInfo items
             */
    
            /**
             * Constructs a new StorageInfo.
             * @memberof rings_node
             * @classdesc Represents a StorageInfo.
             * @implements IStorageInfo
             * @constructor
             * @param {rings_node.IStorageInfo=} [properties] Properties to set
             */
            function StorageInfo(properties) {
                this.items = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StorageInfo items.
             * @member {Array.<rings_node.IStorageItem>} items
             * @memberof rings_node.StorageInfo
             * @instance
             */
            StorageInfo.prototype.items = $util.emptyArray;
    
            /**
             * Creates a new StorageInfo instance using the specified properties.
             * @function create
             * @memberof rings_node.StorageInfo
             * @static
             * @param {rings_node.IStorageInfo=} [properties] Properties to set
             * @returns {rings_node.StorageInfo} StorageInfo instance
             */
            StorageInfo.create = function create(properties) {
                return new StorageInfo(properties);
            };
    
            /**
             * Encodes the specified StorageInfo message. Does not implicitly {@link rings_node.StorageInfo.verify|verify} messages.
             * @function encode
             * @memberof rings_node.StorageInfo
             * @static
             * @param {rings_node.IStorageInfo} message StorageInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.items != null && message.items.length)
                    for (var i = 0; i < message.items.length; ++i)
                        $root.rings_node.StorageItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StorageInfo message, length delimited. Does not implicitly {@link rings_node.StorageInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.StorageInfo
             * @static
             * @param {rings_node.IStorageInfo} message StorageInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StorageInfo message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.StorageInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.StorageInfo} StorageInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.StorageInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.items && message.items.length))
                                message.items = [];
                            message.items.push($root.rings_node.StorageItem.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StorageInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.StorageInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.StorageInfo} StorageInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StorageInfo message.
             * @function verify
             * @memberof rings_node.StorageInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.items != null && message.hasOwnProperty("items")) {
                    if (!Array.isArray(message.items))
                        return "items: array expected";
                    for (var i = 0; i < message.items.length; ++i) {
                        var error = $root.rings_node.StorageItem.verify(message.items[i]);
                        if (error)
                            return "items." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StorageInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.StorageInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.StorageInfo} StorageInfo
             */
            StorageInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.StorageInfo)
                    return object;
                var message = new $root.rings_node.StorageInfo();
                if (object.items) {
                    if (!Array.isArray(object.items))
                        throw TypeError(".rings_node.StorageInfo.items: array expected");
                    message.items = [];
                    for (var i = 0; i < object.items.length; ++i) {
                        if (typeof object.items[i] !== "object")
                            throw TypeError(".rings_node.StorageInfo.items: object expected");
                        message.items[i] = $root.rings_node.StorageItem.fromObject(object.items[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StorageInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.StorageInfo
             * @static
             * @param {rings_node.StorageInfo} message StorageInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.items = [];
                if (message.items && message.items.length) {
                    object.items = [];
                    for (var j = 0; j < message.items.length; ++j)
                        object.items[j] = $root.rings_node.StorageItem.toObject(message.items[j], options);
                }
                return object;
            };
    
            /**
             * Converts this StorageInfo to JSON.
             * @function toJSON
             * @memberof rings_node.StorageInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for StorageInfo
             * @function getTypeUrl
             * @memberof rings_node.StorageInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StorageInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.StorageInfo";
            };
    
            return StorageInfo;
        })();
    
        rings_node.SwarmInfo = (function() {
    
            /**
             * Properties of a SwarmInfo.
             * @memberof rings_node
             * @interface ISwarmInfo
             * @property {Array.<rings_node.IPeerInfo>|null} [peers] SwarmInfo peers
             * @property {rings_node.IDhtInfo|null} [dht] SwarmInfo dht
             * @property {rings_node.IStorageInfo|null} [persistence_storage] SwarmInfo persistence_storage
             * @property {rings_node.IStorageInfo|null} [cache_storage] SwarmInfo cache_storage
             */
    
            /**
             * Constructs a new SwarmInfo.
             * @memberof rings_node
             * @classdesc Represents a SwarmInfo.
             * @implements ISwarmInfo
             * @constructor
             * @param {rings_node.ISwarmInfo=} [properties] Properties to set
             */
            function SwarmInfo(properties) {
                this.peers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SwarmInfo peers.
             * @member {Array.<rings_node.IPeerInfo>} peers
             * @memberof rings_node.SwarmInfo
             * @instance
             */
            SwarmInfo.prototype.peers = $util.emptyArray;
    
            /**
             * SwarmInfo dht.
             * @member {rings_node.IDhtInfo|null|undefined} dht
             * @memberof rings_node.SwarmInfo
             * @instance
             */
            SwarmInfo.prototype.dht = null;
    
            /**
             * SwarmInfo persistence_storage.
             * @member {rings_node.IStorageInfo|null|undefined} persistence_storage
             * @memberof rings_node.SwarmInfo
             * @instance
             */
            SwarmInfo.prototype.persistence_storage = null;
    
            /**
             * SwarmInfo cache_storage.
             * @member {rings_node.IStorageInfo|null|undefined} cache_storage
             * @memberof rings_node.SwarmInfo
             * @instance
             */
            SwarmInfo.prototype.cache_storage = null;
    
            /**
             * Creates a new SwarmInfo instance using the specified properties.
             * @function create
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {rings_node.ISwarmInfo=} [properties] Properties to set
             * @returns {rings_node.SwarmInfo} SwarmInfo instance
             */
            SwarmInfo.create = function create(properties) {
                return new SwarmInfo(properties);
            };
    
            /**
             * Encodes the specified SwarmInfo message. Does not implicitly {@link rings_node.SwarmInfo.verify|verify} messages.
             * @function encode
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {rings_node.ISwarmInfo} message SwarmInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwarmInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers != null && message.peers.length)
                    for (var i = 0; i < message.peers.length; ++i)
                        $root.rings_node.PeerInfo.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.dht != null && Object.hasOwnProperty.call(message, "dht"))
                    $root.rings_node.DhtInfo.encode(message.dht, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.persistence_storage != null && Object.hasOwnProperty.call(message, "persistence_storage"))
                    $root.rings_node.StorageInfo.encode(message.persistence_storage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cache_storage != null && Object.hasOwnProperty.call(message, "cache_storage"))
                    $root.rings_node.StorageInfo.encode(message.cache_storage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SwarmInfo message, length delimited. Does not implicitly {@link rings_node.SwarmInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {rings_node.ISwarmInfo} message SwarmInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwarmInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SwarmInfo message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.SwarmInfo} SwarmInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwarmInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.SwarmInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.peers && message.peers.length))
                                message.peers = [];
                            message.peers.push($root.rings_node.PeerInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.dht = $root.rings_node.DhtInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.persistence_storage = $root.rings_node.StorageInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.cache_storage = $root.rings_node.StorageInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SwarmInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.SwarmInfo} SwarmInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwarmInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SwarmInfo message.
             * @function verify
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwarmInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers != null && message.hasOwnProperty("peers")) {
                    if (!Array.isArray(message.peers))
                        return "peers: array expected";
                    for (var i = 0; i < message.peers.length; ++i) {
                        var error = $root.rings_node.PeerInfo.verify(message.peers[i]);
                        if (error)
                            return "peers." + error;
                    }
                }
                if (message.dht != null && message.hasOwnProperty("dht")) {
                    var error = $root.rings_node.DhtInfo.verify(message.dht);
                    if (error)
                        return "dht." + error;
                }
                if (message.persistence_storage != null && message.hasOwnProperty("persistence_storage")) {
                    var error = $root.rings_node.StorageInfo.verify(message.persistence_storage);
                    if (error)
                        return "persistence_storage." + error;
                }
                if (message.cache_storage != null && message.hasOwnProperty("cache_storage")) {
                    var error = $root.rings_node.StorageInfo.verify(message.cache_storage);
                    if (error)
                        return "cache_storage." + error;
                }
                return null;
            };
    
            /**
             * Creates a SwarmInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.SwarmInfo} SwarmInfo
             */
            SwarmInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.SwarmInfo)
                    return object;
                var message = new $root.rings_node.SwarmInfo();
                if (object.peers) {
                    if (!Array.isArray(object.peers))
                        throw TypeError(".rings_node.SwarmInfo.peers: array expected");
                    message.peers = [];
                    for (var i = 0; i < object.peers.length; ++i) {
                        if (typeof object.peers[i] !== "object")
                            throw TypeError(".rings_node.SwarmInfo.peers: object expected");
                        message.peers[i] = $root.rings_node.PeerInfo.fromObject(object.peers[i]);
                    }
                }
                if (object.dht != null) {
                    if (typeof object.dht !== "object")
                        throw TypeError(".rings_node.SwarmInfo.dht: object expected");
                    message.dht = $root.rings_node.DhtInfo.fromObject(object.dht);
                }
                if (object.persistence_storage != null) {
                    if (typeof object.persistence_storage !== "object")
                        throw TypeError(".rings_node.SwarmInfo.persistence_storage: object expected");
                    message.persistence_storage = $root.rings_node.StorageInfo.fromObject(object.persistence_storage);
                }
                if (object.cache_storage != null) {
                    if (typeof object.cache_storage !== "object")
                        throw TypeError(".rings_node.SwarmInfo.cache_storage: object expected");
                    message.cache_storage = $root.rings_node.StorageInfo.fromObject(object.cache_storage);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SwarmInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {rings_node.SwarmInfo} message SwarmInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwarmInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.peers = [];
                if (options.defaults) {
                    object.dht = null;
                    object.persistence_storage = null;
                    object.cache_storage = null;
                }
                if (message.peers && message.peers.length) {
                    object.peers = [];
                    for (var j = 0; j < message.peers.length; ++j)
                        object.peers[j] = $root.rings_node.PeerInfo.toObject(message.peers[j], options);
                }
                if (message.dht != null && message.hasOwnProperty("dht"))
                    object.dht = $root.rings_node.DhtInfo.toObject(message.dht, options);
                if (message.persistence_storage != null && message.hasOwnProperty("persistence_storage"))
                    object.persistence_storage = $root.rings_node.StorageInfo.toObject(message.persistence_storage, options);
                if (message.cache_storage != null && message.hasOwnProperty("cache_storage"))
                    object.cache_storage = $root.rings_node.StorageInfo.toObject(message.cache_storage, options);
                return object;
            };
    
            /**
             * Converts this SwarmInfo to JSON.
             * @function toJSON
             * @memberof rings_node.SwarmInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwarmInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SwarmInfo
             * @function getTypeUrl
             * @memberof rings_node.SwarmInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwarmInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.SwarmInfo";
            };
    
            return SwarmInfo;
        })();
    
        rings_node.NodeInfoResponse = (function() {
    
            /**
             * Properties of a NodeInfoResponse.
             * @memberof rings_node
             * @interface INodeInfoResponse
             * @property {string|null} [version] NodeInfoResponse version
             * @property {rings_node.ISwarmInfo|null} [swarm] NodeInfoResponse swarm
             */
    
            /**
             * Constructs a new NodeInfoResponse.
             * @memberof rings_node
             * @classdesc Represents a NodeInfoResponse.
             * @implements INodeInfoResponse
             * @constructor
             * @param {rings_node.INodeInfoResponse=} [properties] Properties to set
             */
            function NodeInfoResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NodeInfoResponse version.
             * @member {string} version
             * @memberof rings_node.NodeInfoResponse
             * @instance
             */
            NodeInfoResponse.prototype.version = "";
    
            /**
             * NodeInfoResponse swarm.
             * @member {rings_node.ISwarmInfo|null|undefined} swarm
             * @memberof rings_node.NodeInfoResponse
             * @instance
             */
            NodeInfoResponse.prototype.swarm = null;
    
            /**
             * Creates a new NodeInfoResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {rings_node.INodeInfoResponse=} [properties] Properties to set
             * @returns {rings_node.NodeInfoResponse} NodeInfoResponse instance
             */
            NodeInfoResponse.create = function create(properties) {
                return new NodeInfoResponse(properties);
            };
    
            /**
             * Encodes the specified NodeInfoResponse message. Does not implicitly {@link rings_node.NodeInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {rings_node.INodeInfoResponse} message NodeInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.swarm != null && Object.hasOwnProperty.call(message, "swarm"))
                    $root.rings_node.SwarmInfo.encode(message.swarm, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NodeInfoResponse message, length delimited. Does not implicitly {@link rings_node.NodeInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {rings_node.INodeInfoResponse} message NodeInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NodeInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.NodeInfoResponse} NodeInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.NodeInfoResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.version = reader.string();
                            break;
                        }
                    case 2: {
                            message.swarm = $root.rings_node.SwarmInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NodeInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.NodeInfoResponse} NodeInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NodeInfoResponse message.
             * @function verify
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.swarm != null && message.hasOwnProperty("swarm")) {
                    var error = $root.rings_node.SwarmInfo.verify(message.swarm);
                    if (error)
                        return "swarm." + error;
                }
                return null;
            };
    
            /**
             * Creates a NodeInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.NodeInfoResponse} NodeInfoResponse
             */
            NodeInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.NodeInfoResponse)
                    return object;
                var message = new $root.rings_node.NodeInfoResponse();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.swarm != null) {
                    if (typeof object.swarm !== "object")
                        throw TypeError(".rings_node.NodeInfoResponse.swarm: object expected");
                    message.swarm = $root.rings_node.SwarmInfo.fromObject(object.swarm);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NodeInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {rings_node.NodeInfoResponse} message NodeInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = "";
                    object.swarm = null;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.swarm != null && message.hasOwnProperty("swarm"))
                    object.swarm = $root.rings_node.SwarmInfo.toObject(message.swarm, options);
                return object;
            };
    
            /**
             * Converts this NodeInfoResponse to JSON.
             * @function toJSON
             * @memberof rings_node.NodeInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for NodeInfoResponse
             * @function getTypeUrl
             * @memberof rings_node.NodeInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.NodeInfoResponse";
            };
    
            return NodeInfoResponse;
        })();
    
        rings_node.NodeDidRequest = (function() {
    
            /**
             * Properties of a NodeDidRequest.
             * @memberof rings_node
             * @interface INodeDidRequest
             */
    
            /**
             * Constructs a new NodeDidRequest.
             * @memberof rings_node
             * @classdesc Represents a NodeDidRequest.
             * @implements INodeDidRequest
             * @constructor
             * @param {rings_node.INodeDidRequest=} [properties] Properties to set
             */
            function NodeDidRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new NodeDidRequest instance using the specified properties.
             * @function create
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {rings_node.INodeDidRequest=} [properties] Properties to set
             * @returns {rings_node.NodeDidRequest} NodeDidRequest instance
             */
            NodeDidRequest.create = function create(properties) {
                return new NodeDidRequest(properties);
            };
    
            /**
             * Encodes the specified NodeDidRequest message. Does not implicitly {@link rings_node.NodeDidRequest.verify|verify} messages.
             * @function encode
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {rings_node.INodeDidRequest} message NodeDidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeDidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified NodeDidRequest message, length delimited. Does not implicitly {@link rings_node.NodeDidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {rings_node.INodeDidRequest} message NodeDidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeDidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NodeDidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.NodeDidRequest} NodeDidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeDidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.NodeDidRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NodeDidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.NodeDidRequest} NodeDidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeDidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NodeDidRequest message.
             * @function verify
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeDidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a NodeDidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.NodeDidRequest} NodeDidRequest
             */
            NodeDidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.NodeDidRequest)
                    return object;
                return new $root.rings_node.NodeDidRequest();
            };
    
            /**
             * Creates a plain object from a NodeDidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {rings_node.NodeDidRequest} message NodeDidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeDidRequest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this NodeDidRequest to JSON.
             * @function toJSON
             * @memberof rings_node.NodeDidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeDidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for NodeDidRequest
             * @function getTypeUrl
             * @memberof rings_node.NodeDidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeDidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.NodeDidRequest";
            };
    
            return NodeDidRequest;
        })();
    
        rings_node.NodeDidResponse = (function() {
    
            /**
             * Properties of a NodeDidResponse.
             * @memberof rings_node
             * @interface INodeDidResponse
             * @property {string|null} [did] NodeDidResponse did
             */
    
            /**
             * Constructs a new NodeDidResponse.
             * @memberof rings_node
             * @classdesc Represents a NodeDidResponse.
             * @implements INodeDidResponse
             * @constructor
             * @param {rings_node.INodeDidResponse=} [properties] Properties to set
             */
            function NodeDidResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NodeDidResponse did.
             * @member {string} did
             * @memberof rings_node.NodeDidResponse
             * @instance
             */
            NodeDidResponse.prototype.did = "";
    
            /**
             * Creates a new NodeDidResponse instance using the specified properties.
             * @function create
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {rings_node.INodeDidResponse=} [properties] Properties to set
             * @returns {rings_node.NodeDidResponse} NodeDidResponse instance
             */
            NodeDidResponse.create = function create(properties) {
                return new NodeDidResponse(properties);
            };
    
            /**
             * Encodes the specified NodeDidResponse message. Does not implicitly {@link rings_node.NodeDidResponse.verify|verify} messages.
             * @function encode
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {rings_node.INodeDidResponse} message NodeDidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeDidResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.did);
                return writer;
            };
    
            /**
             * Encodes the specified NodeDidResponse message, length delimited. Does not implicitly {@link rings_node.NodeDidResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {rings_node.INodeDidResponse} message NodeDidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeDidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NodeDidResponse message from the specified reader or buffer.
             * @function decode
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rings_node.NodeDidResponse} NodeDidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeDidResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rings_node.NodeDidResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.did = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NodeDidResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rings_node.NodeDidResponse} NodeDidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeDidResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NodeDidResponse message.
             * @function verify
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeDidResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.did != null && message.hasOwnProperty("did"))
                    if (!$util.isString(message.did))
                        return "did: string expected";
                return null;
            };
    
            /**
             * Creates a NodeDidResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rings_node.NodeDidResponse} NodeDidResponse
             */
            NodeDidResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.rings_node.NodeDidResponse)
                    return object;
                var message = new $root.rings_node.NodeDidResponse();
                if (object.did != null)
                    message.did = String(object.did);
                return message;
            };
    
            /**
             * Creates a plain object from a NodeDidResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {rings_node.NodeDidResponse} message NodeDidResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeDidResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.did = "";
                if (message.did != null && message.hasOwnProperty("did"))
                    object.did = message.did;
                return object;
            };
    
            /**
             * Converts this NodeDidResponse to JSON.
             * @function toJSON
             * @memberof rings_node.NodeDidResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeDidResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for NodeDidResponse
             * @function getTypeUrl
             * @memberof rings_node.NodeDidResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeDidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rings_node.NodeDidResponse";
            };
    
            return NodeDidResponse;
        })();
    
        rings_node.InternalService = (function() {
    
            /**
             * Constructs a new InternalService service.
             * @memberof rings_node
             * @classdesc Represents an InternalService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function InternalService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (InternalService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = InternalService;
    
            /**
             * Creates new InternalService service using the specified rpc implementation.
             * @function create
             * @memberof rings_node.InternalService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {InternalService} RPC service. Useful where requests and/or responses are streamed.
             */
            InternalService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link rings_node.InternalService#connectPeerViaHttp}.
             * @memberof rings_node.InternalService
             * @typedef ConnectPeerViaHttpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.ConnectPeerViaHttpResponse} [response] ConnectPeerViaHttpResponse
             */
    
            /**
             * Calls ConnectPeerViaHttp.
             * @function connectPeerViaHttp
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IConnectPeerViaHttpRequest} request ConnectPeerViaHttpRequest message or plain object
             * @param {rings_node.InternalService.ConnectPeerViaHttpCallback} callback Node-style callback called with the error, if any, and ConnectPeerViaHttpResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.connectPeerViaHttp = function connectPeerViaHttp(request, callback) {
                return this.rpcCall(connectPeerViaHttp, $root.rings_node.ConnectPeerViaHttpRequest, $root.rings_node.ConnectPeerViaHttpResponse, request, callback);
            }, "name", { value: "ConnectPeerViaHttp" });
    
            /**
             * Calls ConnectPeerViaHttp.
             * @function connectPeerViaHttp
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IConnectPeerViaHttpRequest} request ConnectPeerViaHttpRequest message or plain object
             * @returns {Promise<rings_node.ConnectPeerViaHttpResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#connectWithDid}.
             * @memberof rings_node.InternalService
             * @typedef ConnectWithDidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.ConnectWithDidResponse} [response] ConnectWithDidResponse
             */
    
            /**
             * Calls ConnectWithDid.
             * @function connectWithDid
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IConnectWithDidRequest} request ConnectWithDidRequest message or plain object
             * @param {rings_node.InternalService.ConnectWithDidCallback} callback Node-style callback called with the error, if any, and ConnectWithDidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.connectWithDid = function connectWithDid(request, callback) {
                return this.rpcCall(connectWithDid, $root.rings_node.ConnectWithDidRequest, $root.rings_node.ConnectWithDidResponse, request, callback);
            }, "name", { value: "ConnectWithDid" });
    
            /**
             * Calls ConnectWithDid.
             * @function connectWithDid
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IConnectWithDidRequest} request ConnectWithDidRequest message or plain object
             * @returns {Promise<rings_node.ConnectWithDidResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#connectWithSeed}.
             * @memberof rings_node.InternalService
             * @typedef ConnectWithSeedCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.ConnectWithSeedResponse} [response] ConnectWithSeedResponse
             */
    
            /**
             * Calls ConnectWithSeed.
             * @function connectWithSeed
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IConnectWithSeedRequest} request ConnectWithSeedRequest message or plain object
             * @param {rings_node.InternalService.ConnectWithSeedCallback} callback Node-style callback called with the error, if any, and ConnectWithSeedResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.connectWithSeed = function connectWithSeed(request, callback) {
                return this.rpcCall(connectWithSeed, $root.rings_node.ConnectWithSeedRequest, $root.rings_node.ConnectWithSeedResponse, request, callback);
            }, "name", { value: "ConnectWithSeed" });
    
            /**
             * Calls ConnectWithSeed.
             * @function connectWithSeed
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IConnectWithSeedRequest} request ConnectWithSeedRequest message or plain object
             * @returns {Promise<rings_node.ConnectWithSeedResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#listPeers}.
             * @memberof rings_node.InternalService
             * @typedef ListPeersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.ListPeersResponse} [response] ListPeersResponse
             */
    
            /**
             * Calls ListPeers.
             * @function listPeers
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IListPeersRequest} request ListPeersRequest message or plain object
             * @param {rings_node.InternalService.ListPeersCallback} callback Node-style callback called with the error, if any, and ListPeersResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.listPeers = function listPeers(request, callback) {
                return this.rpcCall(listPeers, $root.rings_node.ListPeersRequest, $root.rings_node.ListPeersResponse, request, callback);
            }, "name", { value: "ListPeers" });
    
            /**
             * Calls ListPeers.
             * @function listPeers
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IListPeersRequest} request ListPeersRequest message or plain object
             * @returns {Promise<rings_node.ListPeersResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#createOffer}.
             * @memberof rings_node.InternalService
             * @typedef CreateOfferCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.CreateOfferResponse} [response] CreateOfferResponse
             */
    
            /**
             * Calls CreateOffer.
             * @function createOffer
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ICreateOfferRequest} request CreateOfferRequest message or plain object
             * @param {rings_node.InternalService.CreateOfferCallback} callback Node-style callback called with the error, if any, and CreateOfferResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.createOffer = function createOffer(request, callback) {
                return this.rpcCall(createOffer, $root.rings_node.CreateOfferRequest, $root.rings_node.CreateOfferResponse, request, callback);
            }, "name", { value: "CreateOffer" });
    
            /**
             * Calls CreateOffer.
             * @function createOffer
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ICreateOfferRequest} request CreateOfferRequest message or plain object
             * @returns {Promise<rings_node.CreateOfferResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#answerOffer}.
             * @memberof rings_node.InternalService
             * @typedef AnswerOfferCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.AnswerOfferResponse} [response] AnswerOfferResponse
             */
    
            /**
             * Calls AnswerOffer.
             * @function answerOffer
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IAnswerOfferRequest} request AnswerOfferRequest message or plain object
             * @param {rings_node.InternalService.AnswerOfferCallback} callback Node-style callback called with the error, if any, and AnswerOfferResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.answerOffer = function answerOffer(request, callback) {
                return this.rpcCall(answerOffer, $root.rings_node.AnswerOfferRequest, $root.rings_node.AnswerOfferResponse, request, callback);
            }, "name", { value: "AnswerOffer" });
    
            /**
             * Calls AnswerOffer.
             * @function answerOffer
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IAnswerOfferRequest} request AnswerOfferRequest message or plain object
             * @returns {Promise<rings_node.AnswerOfferResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#acceptAnswer}.
             * @memberof rings_node.InternalService
             * @typedef AcceptAnswerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.AcceptAnswerResponse} [response] AcceptAnswerResponse
             */
    
            /**
             * Calls AcceptAnswer.
             * @function acceptAnswer
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IAcceptAnswerRequest} request AcceptAnswerRequest message or plain object
             * @param {rings_node.InternalService.AcceptAnswerCallback} callback Node-style callback called with the error, if any, and AcceptAnswerResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.acceptAnswer = function acceptAnswer(request, callback) {
                return this.rpcCall(acceptAnswer, $root.rings_node.AcceptAnswerRequest, $root.rings_node.AcceptAnswerResponse, request, callback);
            }, "name", { value: "AcceptAnswer" });
    
            /**
             * Calls AcceptAnswer.
             * @function acceptAnswer
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IAcceptAnswerRequest} request AcceptAnswerRequest message or plain object
             * @returns {Promise<rings_node.AcceptAnswerResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#disconnect}.
             * @memberof rings_node.InternalService
             * @typedef DisconnectCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.DisconnectResponse} [response] DisconnectResponse
             */
    
            /**
             * Calls Disconnect.
             * @function disconnect
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IDisconnectRequest} request DisconnectRequest message or plain object
             * @param {rings_node.InternalService.DisconnectCallback} callback Node-style callback called with the error, if any, and DisconnectResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.disconnect = function disconnect(request, callback) {
                return this.rpcCall(disconnect, $root.rings_node.DisconnectRequest, $root.rings_node.DisconnectResponse, request, callback);
            }, "name", { value: "Disconnect" });
    
            /**
             * Calls Disconnect.
             * @function disconnect
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IDisconnectRequest} request DisconnectRequest message or plain object
             * @returns {Promise<rings_node.DisconnectResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#sendCustomMessage}.
             * @memberof rings_node.InternalService
             * @typedef SendCustomMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.SendCustomMessageResponse} [response] SendCustomMessageResponse
             */
    
            /**
             * Calls SendCustomMessage.
             * @function sendCustomMessage
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ISendCustomMessageRequest} request SendCustomMessageRequest message or plain object
             * @param {rings_node.InternalService.SendCustomMessageCallback} callback Node-style callback called with the error, if any, and SendCustomMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.sendCustomMessage = function sendCustomMessage(request, callback) {
                return this.rpcCall(sendCustomMessage, $root.rings_node.SendCustomMessageRequest, $root.rings_node.SendCustomMessageResponse, request, callback);
            }, "name", { value: "SendCustomMessage" });
    
            /**
             * Calls SendCustomMessage.
             * @function sendCustomMessage
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ISendCustomMessageRequest} request SendCustomMessageRequest message or plain object
             * @returns {Promise<rings_node.SendCustomMessageResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#sendBackendMessage}.
             * @memberof rings_node.InternalService
             * @typedef SendBackendMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.SendBackendMessageResponse} [response] SendBackendMessageResponse
             */
    
            /**
             * Calls SendBackendMessage.
             * @function sendBackendMessage
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ISendBackendMessageRequest} request SendBackendMessageRequest message or plain object
             * @param {rings_node.InternalService.SendBackendMessageCallback} callback Node-style callback called with the error, if any, and SendBackendMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.sendBackendMessage = function sendBackendMessage(request, callback) {
                return this.rpcCall(sendBackendMessage, $root.rings_node.SendBackendMessageRequest, $root.rings_node.SendBackendMessageResponse, request, callback);
            }, "name", { value: "SendBackendMessage" });
    
            /**
             * Calls SendBackendMessage.
             * @function sendBackendMessage
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ISendBackendMessageRequest} request SendBackendMessageRequest message or plain object
             * @returns {Promise<rings_node.SendBackendMessageResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#publishMessageToTopic}.
             * @memberof rings_node.InternalService
             * @typedef PublishMessageToTopicCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.PublishMessageToTopicResponse} [response] PublishMessageToTopicResponse
             */
    
            /**
             * Calls PublishMessageToTopic.
             * @function publishMessageToTopic
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IPublishMessageToTopicRequest} request PublishMessageToTopicRequest message or plain object
             * @param {rings_node.InternalService.PublishMessageToTopicCallback} callback Node-style callback called with the error, if any, and PublishMessageToTopicResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.publishMessageToTopic = function publishMessageToTopic(request, callback) {
                return this.rpcCall(publishMessageToTopic, $root.rings_node.PublishMessageToTopicRequest, $root.rings_node.PublishMessageToTopicResponse, request, callback);
            }, "name", { value: "PublishMessageToTopic" });
    
            /**
             * Calls PublishMessageToTopic.
             * @function publishMessageToTopic
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IPublishMessageToTopicRequest} request PublishMessageToTopicRequest message or plain object
             * @returns {Promise<rings_node.PublishMessageToTopicResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#fetchTopicMessages}.
             * @memberof rings_node.InternalService
             * @typedef FetchTopicMessagesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.FetchTopicMessagesResponse} [response] FetchTopicMessagesResponse
             */
    
            /**
             * Calls FetchTopicMessages.
             * @function fetchTopicMessages
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IFetchTopicMessagesRequest} request FetchTopicMessagesRequest message or plain object
             * @param {rings_node.InternalService.FetchTopicMessagesCallback} callback Node-style callback called with the error, if any, and FetchTopicMessagesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.fetchTopicMessages = function fetchTopicMessages(request, callback) {
                return this.rpcCall(fetchTopicMessages, $root.rings_node.FetchTopicMessagesRequest, $root.rings_node.FetchTopicMessagesResponse, request, callback);
            }, "name", { value: "FetchTopicMessages" });
    
            /**
             * Calls FetchTopicMessages.
             * @function fetchTopicMessages
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IFetchTopicMessagesRequest} request FetchTopicMessagesRequest message or plain object
             * @returns {Promise<rings_node.FetchTopicMessagesResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#registerService}.
             * @memberof rings_node.InternalService
             * @typedef RegisterServiceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.RegisterServiceResponse} [response] RegisterServiceResponse
             */
    
            /**
             * Calls RegisterService.
             * @function registerService
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IRegisterServiceRequest} request RegisterServiceRequest message or plain object
             * @param {rings_node.InternalService.RegisterServiceCallback} callback Node-style callback called with the error, if any, and RegisterServiceResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.registerService = function registerService(request, callback) {
                return this.rpcCall(registerService, $root.rings_node.RegisterServiceRequest, $root.rings_node.RegisterServiceResponse, request, callback);
            }, "name", { value: "RegisterService" });
    
            /**
             * Calls RegisterService.
             * @function registerService
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.IRegisterServiceRequest} request RegisterServiceRequest message or plain object
             * @returns {Promise<rings_node.RegisterServiceResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#lookupService}.
             * @memberof rings_node.InternalService
             * @typedef LookupServiceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.LookupServiceResponse} [response] LookupServiceResponse
             */
    
            /**
             * Calls LookupService.
             * @function lookupService
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ILookupServiceRequest} request LookupServiceRequest message or plain object
             * @param {rings_node.InternalService.LookupServiceCallback} callback Node-style callback called with the error, if any, and LookupServiceResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.lookupService = function lookupService(request, callback) {
                return this.rpcCall(lookupService, $root.rings_node.LookupServiceRequest, $root.rings_node.LookupServiceResponse, request, callback);
            }, "name", { value: "LookupService" });
    
            /**
             * Calls LookupService.
             * @function lookupService
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.ILookupServiceRequest} request LookupServiceRequest message or plain object
             * @returns {Promise<rings_node.LookupServiceResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#nodeInfo}.
             * @memberof rings_node.InternalService
             * @typedef NodeInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.NodeInfoResponse} [response] NodeInfoResponse
             */
    
            /**
             * Calls NodeInfo.
             * @function nodeInfo
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.INodeInfoRequest} request NodeInfoRequest message or plain object
             * @param {rings_node.InternalService.NodeInfoCallback} callback Node-style callback called with the error, if any, and NodeInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.nodeInfo = function nodeInfo(request, callback) {
                return this.rpcCall(nodeInfo, $root.rings_node.NodeInfoRequest, $root.rings_node.NodeInfoResponse, request, callback);
            }, "name", { value: "NodeInfo" });
    
            /**
             * Calls NodeInfo.
             * @function nodeInfo
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.INodeInfoRequest} request NodeInfoRequest message or plain object
             * @returns {Promise<rings_node.NodeInfoResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.InternalService#nodeDid}.
             * @memberof rings_node.InternalService
             * @typedef NodeDidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.NodeDidResponse} [response] NodeDidResponse
             */
    
            /**
             * Calls NodeDid.
             * @function nodeDid
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.INodeDidRequest} request NodeDidRequest message or plain object
             * @param {rings_node.InternalService.NodeDidCallback} callback Node-style callback called with the error, if any, and NodeDidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(InternalService.prototype.nodeDid = function nodeDid(request, callback) {
                return this.rpcCall(nodeDid, $root.rings_node.NodeDidRequest, $root.rings_node.NodeDidResponse, request, callback);
            }, "name", { value: "NodeDid" });
    
            /**
             * Calls NodeDid.
             * @function nodeDid
             * @memberof rings_node.InternalService
             * @instance
             * @param {rings_node.INodeDidRequest} request NodeDidRequest message or plain object
             * @returns {Promise<rings_node.NodeDidResponse>} Promise
             * @variation 2
             */
    
            return InternalService;
        })();
    
        rings_node.ExternalService = (function() {
    
            /**
             * Constructs a new ExternalService service.
             * @memberof rings_node
             * @classdesc Represents an ExternalService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ExternalService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (ExternalService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ExternalService;
    
            /**
             * Creates new ExternalService service using the specified rpc implementation.
             * @function create
             * @memberof rings_node.ExternalService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ExternalService} RPC service. Useful where requests and/or responses are streamed.
             */
            ExternalService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link rings_node.ExternalService#answerOffer}.
             * @memberof rings_node.ExternalService
             * @typedef AnswerOfferCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.AnswerOfferResponse} [response] AnswerOfferResponse
             */
    
            /**
             * Calls AnswerOffer.
             * @function answerOffer
             * @memberof rings_node.ExternalService
             * @instance
             * @param {rings_node.IAnswerOfferRequest} request AnswerOfferRequest message or plain object
             * @param {rings_node.ExternalService.AnswerOfferCallback} callback Node-style callback called with the error, if any, and AnswerOfferResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ExternalService.prototype.answerOffer = function answerOffer(request, callback) {
                return this.rpcCall(answerOffer, $root.rings_node.AnswerOfferRequest, $root.rings_node.AnswerOfferResponse, request, callback);
            }, "name", { value: "AnswerOffer" });
    
            /**
             * Calls AnswerOffer.
             * @function answerOffer
             * @memberof rings_node.ExternalService
             * @instance
             * @param {rings_node.IAnswerOfferRequest} request AnswerOfferRequest message or plain object
             * @returns {Promise<rings_node.AnswerOfferResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.ExternalService#nodeInfo}.
             * @memberof rings_node.ExternalService
             * @typedef NodeInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.NodeInfoResponse} [response] NodeInfoResponse
             */
    
            /**
             * Retrieve Node info
             * @function nodeInfo
             * @memberof rings_node.ExternalService
             * @instance
             * @param {rings_node.INodeInfoRequest} request NodeInfoRequest message or plain object
             * @param {rings_node.ExternalService.NodeInfoCallback} callback Node-style callback called with the error, if any, and NodeInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ExternalService.prototype.nodeInfo = function nodeInfo(request, callback) {
                return this.rpcCall(nodeInfo, $root.rings_node.NodeInfoRequest, $root.rings_node.NodeInfoResponse, request, callback);
            }, "name", { value: "NodeInfo" });
    
            /**
             * Retrieve Node info
             * @function nodeInfo
             * @memberof rings_node.ExternalService
             * @instance
             * @param {rings_node.INodeInfoRequest} request NodeInfoRequest message or plain object
             * @returns {Promise<rings_node.NodeInfoResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link rings_node.ExternalService#nodeDid}.
             * @memberof rings_node.ExternalService
             * @typedef NodeDidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {rings_node.NodeDidResponse} [response] NodeDidResponse
             */
    
            /**
             * Retrieve Node DID
             * @function nodeDid
             * @memberof rings_node.ExternalService
             * @instance
             * @param {rings_node.INodeDidRequest} request NodeDidRequest message or plain object
             * @param {rings_node.ExternalService.NodeDidCallback} callback Node-style callback called with the error, if any, and NodeDidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ExternalService.prototype.nodeDid = function nodeDid(request, callback) {
                return this.rpcCall(nodeDid, $root.rings_node.NodeDidRequest, $root.rings_node.NodeDidResponse, request, callback);
            }, "name", { value: "NodeDid" });
    
            /**
             * Retrieve Node DID
             * @function nodeDid
             * @memberof rings_node.ExternalService
             * @instance
             * @param {rings_node.INodeDidRequest} request NodeDidRequest message or plain object
             * @returns {Promise<rings_node.NodeDidResponse>} Promise
             * @variation 2
             */
    
            return ExternalService;
        })();
    
        return rings_node;
    })();

    return $root;
});
