/* tslint:disable */
/* eslint-disable */
/**
* Convert BigInt from js to [Field]
* @param {bigint} v
* @param {SupportedPrimeField} field
* @returns {Field}
*/
export function bigint_to_field(v: bigint, field: SupportedPrimeField): Field;
/**
* set debug for wasm.
* if `true` will print `Debug` message in console,
* otherwise only print `error` message
* @param {boolean} value
*/
export function debug(value: boolean): void;
/**
* set log_level
* @param {string} level
*/
export function log_level(level: string): void;
/**
* @param {LogLevel} level
*/
export function init_logging(level: LogLevel): void;
/**
* Get address from hex pubkey
*  * pubkey: hex pubkey
* @param {string} pubkey
* @returns {string}
*/
export function get_address_from_hex_pubkey(pubkey: string): string;
/**
* Get address from other address
*   * address: source address
*   * addr_type: source address type
* @param {string} address
* @param {AddressType} addr_type
* @returns {string}
*/
export function get_address(address: string, addr_type: AddressType): string;
/**
* Supported prime field
*/
export enum SupportedPrimeField {
/**
* field of vesta curve
*/
  Vesta = 0,
/**
* field of pallas curve
*/
  Pallas = 1,
/**
* bn256 with kzg
*/
  Bn256KZG = 2,
}
/**
*/
export enum LogLevel {
  Debug = 0,
  Info = 1,
  Warn = 2,
  Error = 3,
  Trace = 4,
}
/**
* AddressType enum contains `DEFAULT` and `ED25519`.
*/
export enum AddressType {
/**
* Default address type, hex string of sha1(pubkey)
*/
  DEFAULT = 0,
/**
* Ed25519 style address type, hex string of pubkey
*/
  Ed25519 = 1,
}
/**
* BackendBehaviour is a context instance for handling backend message for browser
*/
export class BackendBehaviour {
  free(): void;
/**
* Create a new instance of message callback, this function accept one argument:
*/
  constructor();
/**
* Get behaviour as dyn obj ref
* @returns {BackendMessageHandlerDynObj}
*/
  as_dyn_obj(): BackendMessageHandlerDynObj;
/**
* Extend backend with other backend
* @param {BackendMessageHandlerDynObj} impl_backend
*/
  extend(impl_backend: BackendMessageHandlerDynObj): void;
/**
* register call back function
* * func: `function(provider: Arc<Provider>, payload: string, message: string) -> Promise<()>`;
* @param {string} method
* @param {Function} func
*/
  on(method: string, func: Function): void;
}
/**
* This struct is used to simulate `impl T`
* We need this structure because wasm_bindgen does not support general type such as
* `dyn T` or `impl T`
* We use Arc instead Box, to make it cloneable.
*/
export class BackendMessageHandlerDynObj {
  free(): void;
}
/**
* Circuit, it's a typeless wrapper of rings_snark circuit
*/
export class Circuit {
  free(): void;
/**
* serialize circuit to json
* @returns {string}
*/
  to_json(): string;
/**
* deserialize circuit from json
* @param {string} s
* @returns {Circuit}
*/
  static from_json(s: string): Circuit;
}
/**
* Field type
*/
export class Field {
  free(): void;
/**
* create field from u64
* @param {bigint} v
* @param {SupportedPrimeField} ty
* @returns {Field}
*/
  static from_u64(v: bigint, ty: SupportedPrimeField): Field;
}
/**
* Input type
*/
export class Input {
  free(): void;
/**
* Convert [["foo", [BigInt(2), BigInt(3)]], ["bar", [BigInt(4), BigInt(5)]]] to Input with given field
* @param {Array<any>} input
* @param {SupportedPrimeField} field
* @returns {Input}
*/
  static from_array(input: Array<any>, field: SupportedPrimeField): Input;
/**
* serialize Input to json
* @returns {string}
*/
  to_json(): string;
/**
* deserialize Input from json
* @param {string} s
* @returns {Input}
*/
  static from_json(s: string): Input;
}
/**
* ProcessorConfig is usually serialized as json or yaml.
* There is a `from_config` method in [ProcessorBuilder] used to initialize the Builder with a serialized ProcessorConfig.
*/
export class ProcessorConfig {
  free(): void;
/**
* Creates a new `ProcessorConfig` instance without an external address.
* @param {string} ice_servers
* @param {SessionSk} session_sk
* @param {bigint} stabilize_timeout
* @returns {ProcessorConfig}
*/
  static new(ice_servers: string, session_sk: SessionSk, stabilize_timeout: bigint): ProcessorConfig;
/**
* Creates a new `ProcessorConfig` instance with an external address.
* @param {string} ice_servers
* @param {SessionSk} session_sk
* @param {bigint} stabilize_timeout
* @param {string} external_address
* @returns {ProcessorConfig}
*/
  static new_with_ext_addr(ice_servers: string, session_sk: SessionSk, stabilize_timeout: bigint, external_address: string): ProcessorConfig;
/**
* Return associated [SessionSk].
* @returns {SessionSk}
*/
  session_sk(): SessionSk;
}
/**
* `ProcessorConfigSerialized` is a serialized version of `ProcessorConfig`.
* Instead of storing the `SessionSk` instance, it stores the dumped string representation of the session secret key.
*/
export class ProcessorConfigSerialized {
  free(): void;
}
/**
* General Provider, which holding reference of Processor
* Provider should be obey memory layout of CLang
* Provider should be export for wasm-bindgen
*/
export class Provider {
  free(): void;
/**
* make provider as an As arc ref
* @returns {ProviderRef}
*/
  as_ref(): ProviderRef;
/**
* Create new instance of Provider, return Promise
* Ice_servers should obey forrmat: "[turn|strun]://<Address>:<Port>;..."
* Account is hex string
* Account should format as same as account_type declared
* Account_type is lowercase string, possible input are: `eip191`, `ed25519`, `bip137`, for more imformation,
* please check [rings_core::ecc]
* Signer should be `async function (proof: string): Promise<Unit8Array>`
* Signer should function as same as account_type declared, Eg: eip191 or secp256k1 or ed25519.
* @param {string} ice_servers
* @param {bigint} stabilize_timeout
* @param {string} account
* @param {string} account_type
* @param {Function} signer
* @param {BackendBehaviour | undefined} [backend_behaviour]
*/
  constructor(ice_servers: string, stabilize_timeout: bigint, account: string, account_type: string, signer: Function, backend_behaviour?: BackendBehaviour);
/**
* Create new provider instance with serialized config (yaml/json)
* @param {string} config
* @param {BackendBehaviour | undefined} [backend]
* @returns {Promise<any>}
*/
  static new_provider_with_serialized_config(config: string, backend?: BackendBehaviour): Promise<any>;
/**
* Create a new provider instance.
* @param {ProcessorConfig} config
* @param {BackendBehaviour | undefined} [backend]
* @returns {Promise<any>}
*/
  static new_provider_with_config(config: ProcessorConfig, backend?: BackendBehaviour): Promise<any>;
/**
*  create new unsigned Provider
* @param {ProcessorConfig} config
* @param {BackendBehaviour | undefined} backend_behaviour
* @param {string} storage_name
* @returns {Promise<any>}
*/
  static new_provider_with_storage(config: ProcessorConfig, backend_behaviour: BackendBehaviour | undefined, storage_name: string): Promise<any>;
/**
* Request local rpc interface
* @param {string} method
* @param {any} params
* @returns {Promise<any>}
*/
  request(method: string, params: any): Promise<any>;
/**
* listen message.
* @returns {Promise<any>}
*/
  listen(): Promise<any>;
/**
* connect peer with remote jsonrpc server url
* @param {string} remote_url
* @returns {Promise<any>}
*/
  connect_peer_via_http(remote_url: string): Promise<any>;
/**
* connect peer with web3 address, without waiting for connection channel connected
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  connect_with_address_without_wait(address: string, addr_type?: AddressType): Promise<any>;
/**
* connect peer with web3 address, and wait for connection channel connected
* example:
* ```typescript
* const provider1 = new Provider()
* const provider2 = new Provider()
* const provider3 = new Provider()
* await create_connection(provider1, provider2);
* await create_connection(provider2, provider3);
* await provider1.connect_with_did(provider3.address())
* ```
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  connect_with_address(address: string, addr_type?: AddressType): Promise<any>;
/**
* list all connect peers
* @returns {Promise<any>}
*/
  list_peers(): Promise<any>;
/**
* get info for self, will return build version and inspection of swarm
* @returns {Promise<any>}
*/
  get_node_info(): Promise<any>;
/**
* disconnect a peer with web3 address
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  disconnect(address: string, addr_type?: AddressType): Promise<any>;
/**
* disconnect all connected nodes
* @returns {Promise<any>}
*/
  disconnect_all(): Promise<any>;
/**
* send custom message to peer.
* @param {string} destination
* @param {Uint8Array} msg
* @returns {Promise<any>}
*/
  send_message(destination: string, msg: Uint8Array): Promise<any>;
/**
* get peer by address
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  get_peer(address: string, addr_type?: AddressType): Promise<any>;
/**
* wait for connection connected
* * address: peer's address
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  wait_for_connected(address: string, addr_type?: AddressType): Promise<any>;
/**
* wait for data channel open
*   * address: peer's address
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  wait_for_data_channel_open(address: string, addr_type?: AddressType): Promise<any>;
/**
* Check local cache
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  storage_check_cache(address: string, addr_type?: AddressType): Promise<any>;
/**
* fetch storage with given did
* @param {string} address
* @param {AddressType | undefined} [addr_type]
* @returns {Promise<any>}
*/
  storage_fetch(address: string, addr_type?: AddressType): Promise<any>;
/**
* store virtual node on DHT
* @param {string} data
* @returns {Promise<any>}
*/
  storage_store(data: string): Promise<any>;
/**
* send http request message to remote
* - destination: did
* - service: service name
* - method: http method
* - path: http path like `/ipfs/abc1234` `/ipns/abc`
* - headers: headers of request
* - body: body of request
* @param {string} destination
* @param {string} service
* @param {string} method
* @param {string} path
* @param {any} headers
* @param {Uint8Array | undefined} [body]
* @param {string | undefined} [rid]
* @returns {Promise<any>}
*/
  send_http_request(destination: string, service: string, method: string, path: string, headers: any, body?: Uint8Array, rid?: string): Promise<any>;
/**
* send simple text message to remote
* - destination: A did of destination
* - text: text message
* @param {string} destination
* @param {string} text
* @returns {Promise<any>}
*/
  send_simple_text_message(destination: string, text: string): Promise<any>;
/**
* lookup service did on DHT by its name
* - name: The name of service
* @param {string} name
* @returns {Promise<any>}
*/
  lookup_service(name: string): Promise<any>;
/**
* get self web3 address
*/
  readonly address: string;
}
/**
* A wrapper of Arc Ref of Provider
*/
export class ProviderRef {
  free(): void;
}
/**
* SNARK message handler
*/
export class SNARKBehaviour {
  free(): void;
/**
* Get behaviour as dyn obj ref
* @returns {BackendMessageHandlerDynObj}
*/
  as_dyn_obj(): BackendMessageHandlerDynObj;
/**
* Handle js native message
* @param {ProviderRef} provider
* @param {any} ctx
* @param {any} msg
* @returns {Promise<any>}
*/
  handle_snark_task_message(provider: ProviderRef, ctx: any, msg: any): Promise<any>;
/**
* gen proof task with circuits, this function is use for solo proof
* you can call [SNARKBehaviour::handle_snark_proof_task_ref] later to finalize the proof
* @param {(Circuit)[]} circuits
* @returns {SNARKProofTaskRef}
*/
  static gen_proof_task_ref(circuits: (Circuit)[]): SNARKProofTaskRef;
/**
* handle snark proof task ref, this function is helpful for js_sys
* @param {SNARKProofTaskRef} data
* @returns {SNARKVerifyTaskRef}
*/
  static handle_snark_proof_task_ref(data: SNARKProofTaskRef): SNARKVerifyTaskRef;
/**
* handle snark verify task ref, this function is helpful for js_sys
* @param {SNARKVerifyTaskRef} data
* @param {SNARKProofTaskRef} snark
* @returns {boolean}
*/
  static handle_snark_verify_task_ref(data: SNARKVerifyTaskRef, snark: SNARKProofTaskRef): boolean;
/**
* send proof task to did
* @param {ProviderRef} provider
* @param {SNARKProofTaskRef} task
* @param {string} did
* @returns {Promise<any>}
*/
  send_proof_task_to(provider: ProviderRef, task: SNARKProofTaskRef, did: string): Promise<any>;
/**
* Generate a proof task and send it to did
* @param {ProviderRef} provider
* @param {(Circuit)[]} circuits
* @param {string} did
* @returns {Promise<any>}
*/
  gen_and_send_proof_task_to(provider: ProviderRef, circuits: (Circuit)[], did: string): Promise<any>;
/**
* create new instance for browser
* which support syntax `new SNARKBehaviour` in browser env
*/
  constructor();
/**
* Clone snarkbehaviour, and hold the arc
* this function is useful on js_sys
* @returns {SNARKBehaviour}
*/
  clone(): SNARKBehaviour;
/**
* Get task result
* @param {string} task_id
* @returns {boolean}
*/
  get_task_result(task_id: string): boolean;
}
/**
* We need this ref to pass Task ref to js_sys
*/
export class SNARKProofTaskRef {
  free(): void;
/**
* Make snark proof task ref splitable
* @param {number} n
* @returns {(SNARKProofTaskRef)[]}
*/
  split(n: number): (SNARKProofTaskRef)[];
/**
* serialize SNARKProofTaskRef to json
* @returns {string}
*/
  to_json(): string;
/**
* deserialize SNARKProofTaskRef from json
* @param {string} s
* @returns {SNARKProofTaskRef}
*/
  static from_json(s: string): SNARKProofTaskRef;
/**
* Clone snark proof ref, and hold the arc
* this function is useful on js_sys
* @returns {SNARKProofTaskRef}
*/
  clone(): SNARKProofTaskRef;
}
/**
* Snark builder
*/
export class SNARKTaskBuilder {
  free(): void;
/**
* create new instance for browser
* which support syntax `new SNARKTaskBuilder` in browser env
* @param {string} r1cs_path
* @param {string} witness_wasm_path
* @param {SupportedPrimeField} field
*/
  constructor(r1cs_path: string, witness_wasm_path: string, field: SupportedPrimeField);
/**
* Load r1cs sand witness from local path
* @param {string} r1cs_path
* @param {string} witness_wasm_path
* @param {SupportedPrimeField} field
* @returns {Promise<SNARKTaskBuilder>}
*/
  static from_local(r1cs_path: string, witness_wasm_path: string, field: SupportedPrimeField): Promise<SNARKTaskBuilder>;
/**
* Load r1cs sand witness from remote url
* @param {string} r1cs_path
* @param {string} witness_wasm_path
* @param {SupportedPrimeField} field
* @returns {Promise<SNARKTaskBuilder>}
*/
  static from_remote(r1cs_path: string, witness_wasm_path: string, field: SupportedPrimeField): Promise<SNARKTaskBuilder>;
/**
* generate recursive circuits
* @param {Input} public_input
* @param {(Input)[]} private_inputs
* @param {number} round
* @returns {(Circuit)[]}
*/
  gen_circuits(public_input: Input, private_inputs: (Input)[], round: number): (Circuit)[];
}
/**
* We need this ref to pass Task ref to js_sys
*/
export class SNARKVerifyTaskRef {
  free(): void;
/**
* serialize SNARKPVerifyRef to json
* @returns {string}
*/
  to_json(): string;
/**
* de serialize SNARKPVerifyRef from json
* @param {string} s
* @returns {SNARKVerifyTaskRef}
*/
  static from_json(s: string): SNARKVerifyTaskRef;
/**
* Clone snark verify ref, and hold the arc
* this function is useful on js_sys
* @returns {SNARKVerifyTaskRef}
*/
  clone(): SNARKVerifyTaskRef;
}
/**
* SessionSk holds the [Session] and its session private key.
* To prove that the message was sent by the [Account] of [Session],
* we need to attach session and the signature signed by sk to the payload.
*
* SessionSk provide a `session` method to clone the session.
* SessionSk also provide `sign` method to sign a message.
*
* To verify the session, use `verify_self()` method of [Session].
* To verify a message, use `verify(msg, sig)` method of [Session].
*/
export class SessionSk {
  free(): void;
}
/**
* SessionSkBuilder is used to build a [SessionSk].
*
* Firstly, you need to provide the account's entity and type to [SessionSkBuilder::new] method.
* Then you can call `pack_session` to get the session dump for signing.
* After signing, you can call `sig` to set the signature back to builder.
* Finally, you can call `build` to get the [SessionSk].
*/
export class SessionSkBuilder {
  free(): void;
/**
* Create a new SessionSkBuilder.
* The "account_type" is lower case of [Account] variant.
* The "account_entity" refers to the entity that is encapsulated by the [Account] variant, in string format.
* @param {string} account_entity
* @param {string} account_type
* @returns {SessionSkBuilder}
*/
  static new(account_entity: string, account_type: string): SessionSkBuilder;
/**
* This is a helper method to let user know if the account params is valid.
* @returns {boolean}
*/
  validate_account(): boolean;
/**
* Construct unsigned_info string for signing.
* @returns {string}
*/
  unsigned_proof(): string;
/**
* Set the signature of session that signed by account.
* @param {Uint8Array} sig
* @returns {SessionSkBuilder}
*/
  set_session_sig(sig: Uint8Array): SessionSkBuilder;
/**
* Set the lifetime of session.
* @param {bigint} ttl_ms
* @returns {SessionSkBuilder}
*/
  set_ttl(ttl_ms: bigint): SessionSkBuilder;
/**
* Build the [SessionSk].
* @returns {SessionSk}
*/
  build(): SessionSk;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_snarkprooftaskref_free: (a: number) => void;
  readonly snarkprooftaskref_split: (a: number, b: number, c: number) => void;
  readonly snarkprooftaskref_to_json: (a: number, b: number) => void;
  readonly snarkprooftaskref_from_json: (a: number, b: number, c: number) => void;
  readonly __wbg_snarkverifytaskref_free: (a: number) => void;
  readonly snarkverifytaskref_to_json: (a: number, b: number) => void;
  readonly snarkverifytaskref_from_json: (a: number, b: number, c: number) => void;
  readonly snarkbehaviour_as_dyn_obj: (a: number) => number;
  readonly snarkbehaviour_handle_snark_task_message: (a: number, b: number, c: number, d: number) => number;
  readonly snarkbehaviour_gen_proof_task_ref: (a: number, b: number, c: number) => void;
  readonly snarkbehaviour_handle_snark_proof_task_ref: (a: number, b: number) => void;
  readonly snarkbehaviour_handle_snark_verify_task_ref: (a: number, b: number, c: number) => void;
  readonly snarkbehaviour_send_proof_task_to: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly snarkbehaviour_gen_and_send_proof_task_to: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly snarkbehaviour_new_instance: () => number;
  readonly snarkbehaviour_clone: (a: number) => number;
  readonly snarktaskbuilder_new_instance: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly bigint_to_field: (a: number, b: number, c: number) => void;
  readonly input_from_array: (a: number, b: number) => number;
  readonly __wbg_snarkbehaviour_free: (a: number) => void;
  readonly snarkbehaviour_get_task_result: (a: number, b: number, c: number, d: number) => void;
  readonly __wbg_input_free: (a: number) => void;
  readonly input_to_json: (a: number, b: number) => void;
  readonly input_from_json: (a: number, b: number, c: number) => void;
  readonly __wbg_circuit_free: (a: number) => void;
  readonly circuit_to_json: (a: number, b: number) => void;
  readonly circuit_from_json: (a: number, b: number, c: number) => void;
  readonly __wbg_field_free: (a: number) => void;
  readonly field_from_u64: (a: number, b: number) => number;
  readonly __wbg_snarktaskbuilder_free: (a: number) => void;
  readonly snarktaskbuilder_from_local: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly snarktaskbuilder_from_remote: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly snarktaskbuilder_gen_circuits: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly __wbg_backendbehaviour_free: (a: number) => void;
  readonly backendbehaviour_new: () => number;
  readonly backendbehaviour_as_dyn_obj: (a: number) => number;
  readonly backendbehaviour_extend: (a: number, b: number) => void;
  readonly backendbehaviour_on: (a: number, b: number, c: number, d: number) => void;
  readonly __wbg_processorconfig_free: (a: number) => void;
  readonly processorconfig_new: (a: number, b: number, c: number, d: number) => number;
  readonly processorconfig_new_with_ext_addr: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly processorconfig_session_sk: (a: number) => number;
  readonly __wbg_processorconfigserialized_free: (a: number) => void;
  readonly debug: (a: number) => void;
  readonly log_level: (a: number, b: number) => void;
  readonly __wbg_provider_free: (a: number) => void;
  readonly snarkverifytaskref_clone: (a: number) => number;
  readonly snarkprooftaskref_clone: (a: number) => number;
  readonly init_logging: (a: number) => void;
  readonly __wbg_backendmessagehandlerdynobj_free: (a: number) => void;
  readonly __wbg_providerref_free: (a: number) => void;
  readonly provider_as_ref: (a: number) => number;
  readonly provider_new_instance: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => number;
  readonly provider_new_provider_with_serialized_config: (a: number, b: number, c: number) => number;
  readonly provider_new_provider_with_config: (a: number, b: number) => number;
  readonly provider_address: (a: number, b: number) => void;
  readonly provider_new_provider_with_storage: (a: number, b: number, c: number, d: number) => number;
  readonly provider_request: (a: number, b: number, c: number, d: number) => number;
  readonly provider_listen: (a: number) => number;
  readonly provider_connect_peer_via_http: (a: number, b: number, c: number) => number;
  readonly provider_connect_with_address_without_wait: (a: number, b: number, c: number, d: number) => number;
  readonly provider_connect_with_address: (a: number, b: number, c: number, d: number) => number;
  readonly provider_list_peers: (a: number) => number;
  readonly provider_get_node_info: (a: number) => number;
  readonly provider_disconnect: (a: number, b: number, c: number, d: number) => number;
  readonly provider_disconnect_all: (a: number) => number;
  readonly provider_send_message: (a: number, b: number, c: number, d: number) => number;
  readonly provider_get_peer: (a: number, b: number, c: number, d: number) => number;
  readonly provider_wait_for_connected: (a: number, b: number, c: number, d: number) => number;
  readonly provider_wait_for_data_channel_open: (a: number, b: number, c: number, d: number) => number;
  readonly provider_storage_check_cache: (a: number, b: number, c: number, d: number) => number;
  readonly provider_storage_fetch: (a: number, b: number, c: number, d: number) => number;
  readonly provider_storage_store: (a: number, b: number, c: number) => number;
  readonly provider_send_http_request: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number) => number;
  readonly provider_send_simple_text_message: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly provider_lookup_service: (a: number, b: number, c: number) => number;
  readonly get_address_from_hex_pubkey: (a: number, b: number, c: number) => void;
  readonly get_address: (a: number, b: number, c: number, d: number) => void;
  readonly __wbg_trap_free: (a: number) => void;
  readonly trap___wbg_wasmer_trap: () => void;
  readonly __wbg_sessionskbuilder_free: (a: number) => void;
  readonly __wbg_sessionsk_free: (a: number) => void;
  readonly sessionskbuilder_new: (a: number, b: number, c: number, d: number) => number;
  readonly sessionskbuilder_validate_account: (a: number) => number;
  readonly sessionskbuilder_unsigned_proof: (a: number, b: number) => void;
  readonly sessionskbuilder_set_session_sig: (a: number, b: number, c: number) => number;
  readonly sessionskbuilder_set_ttl: (a: number, b: number) => number;
  readonly sessionskbuilder_build: (a: number, b: number) => void;
  readonly __wbindgen_export_0: (a: number, b: number) => number;
  readonly __wbindgen_export_1: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly __wbindgen_export_3: (a: number, b: number, c: number) => void;
  readonly __wbindgen_export_4: (a: number, b: number, c: number) => void;
  readonly __wbindgen_export_5: (a: number, b: number) => void;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_export_6: (a: number, b: number, c: number, d: number) => void;
  readonly __wbindgen_export_7: (a: number, b: number, c: number) => void;
  readonly __wbindgen_export_8: (a: number, b: number) => void;
  readonly __wbindgen_export_9: (a: number, b: number, c: number) => void;
  readonly __wbindgen_export_10: (a: number, b: number, c: number) => void;
  readonly __wbindgen_export_11: (a: number) => void;
  readonly __wbindgen_export_12: (a: number, b: number, c: number, d: number) => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
*
* @returns {InitOutput}
*/
export function initSync(module: SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;
